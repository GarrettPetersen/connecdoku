<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>Connecdoku</title>
<link rel="icon" href="favicon.ico">
<meta name="viewport" content="width=device-width,initial-scale=1">
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Fredoka+One&display=swap" rel="stylesheet">
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-1401790448375434"
     crossorigin="anonymous"></script>
<style>
/* --- styles unchanged from earlier versions --- */
:root{--tile:#f6f7f8;--tile-b:#d4d5d6;--s0:#b6e7b2;--s1:#ffe680;--s2:#ffb06a;
       --txt:#222;--btn1:#4caf50;--btn2:#ffb300;--btn3:#e53935}
body{font-family:system-ui,-apple-system,Segoe UI,Helvetica,Arial,sans-serif;
     margin:0;background:#fafafa;color:var(--txt)}
/* Add emoji font support for compound emojis */
.emoji{font-family:"Apple Color Emoji","Segoe UI Emoji","Noto Color Emoji","Android Emoji","EmojiSymbols","EmojiOne Mozilla","Twemoji Mozilla","Segoe UI Symbol",system-ui,-apple-system,Segoe UI,Helvetica,Arial,sans-serif}
#shell{max-width:850px;margin:60px auto 40px;padding:0 12px;position:relative}
@media (max-width: 768px) {
  #shell { margin: 20px auto 20px; padding: 0 8px; }
  #logo { font-size: 36px; margin: 10px 0 20px; }
}
#logo{font-family:'Fredoka One',cursive;font-size:48px;margin:10px 0 28px;
      text-align:center;letter-spacing:1px;color:#222}
.grid{display:grid;grid-template-columns:repeat(5,1fr);gap:10px}
@media (max-width: 768px) {
  .grid { gap: 6px; }
}
.tile,.hdr{border:2px solid var(--tile-b);border-radius:12px;box-sizing:border-box}
.tile{background:var(--tile);padding:6px 8px;display:flex;align-items:center;
      justify-content:center;min-height:90px;text-align:center;cursor:pointer;
      user-select:none;transition:background-color .3s ease}
@media (max-width: 768px) {
  .tile { min-height: 70px; padding: 4px 6px; font-size: 14px; }
}
.hdr{min-height:34px;display:flex;align-items:center;justify-content:center;cursor:pointer;transition:filter .2s ease;text-align:center;white-space:normal;word-spacing:normal}
@media (max-width: 768px) {
  .hdr { min-height: 28px; font-size: 14px; text-align: center; white-space: normal; word-spacing: normal; }
}
.hdr.emoji{font-family:"Apple Color Emoji","Segoe UI Emoji","Noto Color Emoji","Android Emoji","EmojiSymbols","EmojiOne Mozilla","Twemoji Mozilla","Segoe UI Symbol",system-ui,-apple-system,Segoe UI,Helvetica,Arial,sans-serif}
.hdr:hover{filter:brightness(0.9)}
.hdr button{all:unset;cursor:pointer;color:var(--txt)}
.hdr.solved{font-weight:600;border:none;cursor:default}
.hdr.solved:hover{filter:none}
.hdr.solved.pop{animation:pop .3s ease-out}
.rowCredit{margin-top:22px;font-size:13px;text-align:center;color:#777}
#helpIcon{position:absolute;top:-38px;right:16px;font-size:24px;cursor:pointer}
@media (max-width: 768px) {
  #helpIcon { top: 8px; right: 8px; font-size: 20px; }
}
.strike{margin:16px 0;text-align:center;font-size:18px}
.lock0{background:var(--s0)}.lock1{background:var(--s1)}.lock2{background:var(--s2)}
.frozen{cursor:default}.selected{outline:3px solid #2196f3}
.used1{background:var(--btn2)}.used2{background:var(--btn3)}
.disabled{opacity:.5;cursor:default}.disabled button{display:none}
@keyframes pop{0%{transform:scale(.9)}70%{transform:scale(1.05)}100%{transform:scale(1)}}
@keyframes shake{0%,100%{transform:translateX(0)}20%,60%{transform:translateX(-8px)}
                 40%,80%{transform:translateX(8px)}}
.hdr.solved.pop{animation:pop 1s cubic-bezier(.34,1.56,.64,1)}
.shake{animation:shake 1.2s cubic-bezier(.36,0,.66,-.56)}
.modalBg{position:fixed;inset:0;background:rgba(0,0,0,.55);display:none;
         align-items:center;justify-content:center;z-index:20}
.modalBg.show{display:flex}
.modalCard{background:#fff;border-radius:10px;padding:26px 30px;max-width:360px;position:relative}
.modalCard h3{margin-top:0}
.modalCard button.min{position:absolute;top:8px;right:10px;border:none;background:0;font-size:22px;cursor:pointer}
.modalCard button.action{margin-top:18px;padding:8px 14px;border:none;border-radius:6px;background:#4caf50;color:#fff;cursor:pointer}
#shareBtn{position:fixed;bottom:22px;right:22px;background:#4caf50;color:#fff;
          padding:10px 14px;border-radius:50px;display:none;cursor:pointer;
          box-shadow:0 2px 6px rgba(0,0,0,.25);z-index:15}
@media (max-width: 768px) {
  #shareBtn { bottom: 16px; right: 16px; padding: 8px 12px; font-size: 14px; }
}
pre{white-space:pre-wrap;margin:12px 0;font-size:20px}
@media (max-width: 768px) {
  pre { font-size: 16px; margin: 8px 0; }
}
pre.emoji{font-family:"Apple Color Emoji","Segoe UI Emoji","Noto Color Emoji","Android Emoji","EmojiSymbols","EmojiOne Mozilla","Twemoji Mozilla","Segoe UI Symbol",system-ui,-apple-system,Segoe UI,Helvetica,Arial,sans-serif}
</style>
</head>
<body>
  <div id="shell">
    <div id="helpIcon">â“</div><h1 id="logo">Connecdoku</h1>
    <div class="strike" id="strikeTxt"></div>
    <div id="board" class="grid"></div>
    <div id="hintContainer" style="text-align:center;margin:15px 0;display:none;">
      <button id="hintBtn" style="padding:10px 20px;border:none;border-radius:20px;background:#999;color:#fff;cursor:pointer;font-size:14px;font-weight:500;">hint</button>
    </div>
    <p class="rowCredit">Connecdoku was created by <a href="https://x.com/GarrettPetersen" target="_blank">@GarrettPetersen</a></p>
  </div>

<!-- share popup -->
<div id="sharePop" class="modalBg">
  <div class="modalCard">
    <button class="min" id="minShare">Ã—</button>
    <h3 id="popTitle"></h3><pre id="shareGrid"></pre>
    <div id="unsolved"></div>
    <button class="action" id="copy">Copy to clipboard</button>
  </div>
</div>

<!-- GDPR popup -->
<div id="gdprPop" class="modalBg">
  <div class="modalCard">
    <h3>Cookie Consent</h3>
    <p>This website uses cookies to save your game progress and statistics. 
       This helps you continue where you left off and track your performance over time.</p>
    <p>We only use essential cookies for game functionality. No tracking or advertising cookies are used.</p>
    <div style="display:flex;gap:10px;margin-top:20px;">
      <button class="action" id="acceptCookies">Accept</button>
      <button class="action" style="background:#666" id="declineCookies">Decline</button>
    </div>
  </div>
</div>

<!-- help popup -->
<div id="helpPop" class="modalBg">
  <div class="modalCard">
    <button class="min" id="minHelp">Ã—</button>
    <h3>How to Play</h3>
    <p>Swap words by selecting two tiles.<br>
       When you think an entire <strong>row</strong> or <strong>column</strong> matches a hidden category, hit its âœ“ button.<br>
       â€¢ Correct lines lock (colour depends on your strike count).<br>
       â€¢ Wrong checks give a strike â€” after <strong>three</strong> you lose.<br>
       Solve every row <em>and</em> column to win!
    </p>
    <button class="action" id="helpOK">Got it!</button>
  </div>
</div>

<!-- unsolvable puzzle popup -->
<div id="unsolvablePop" class="modalBg">
  <div class="modalCard">
    <h3>âš ï¸ Puzzle Error</h3>
    <p>Your puzzle has become unsolvable. This is a bug in the game.</p>
    <p>Please tweet at <a href="https://x.com/GarrettPetersen" target="_blank">@GarrettPetersen</a> on X to report this issue.</p>
    <div style="display:flex;gap:10px;margin-top:20px;">
      <button class="action" id="resetPuzzle">Reset Puzzle</button>
      <button class="action" style="background:#666" id="closeUnsolvable">Close</button>
    </div>
  </div>
</div>

<div id="shareBtn">Share</div>

<script>
/* ---------- tiny helpers ---------- */
const $=q=>document.querySelector(q);
const $$=q=>document.querySelectorAll(q);
const start=new Date('2025-07-21T00:00:00');
const todayIdx=()=>{
  const now = new Date();
  const localMidnight = new Date(now.getFullYear(), now.getMonth(), now.getDate());
  const startMidnight = new Date(start.getFullYear(), start.getMonth(), start.getDate());
  return Math.floor((localMidnight.getTime()-startMidnight.getTime())/864e5);
};
const clr=['lock0','lock1','lock2'], emj=['ğŸŸ©','ğŸŸ¨','ğŸŸ§'];

/* ---------- cookie management ---------- */
let cookiesAccepted = false;

function setCookie(name, value, days = 365) {
  if (!cookiesAccepted) return;
  const expires = new Date();
  expires.setTime(expires.getTime() + (days * 24 * 60 * 60 * 1000));
  document.cookie = `${name}=${JSON.stringify(value)};expires=${expires.toUTCString()};path=/`;
}

function getCookie(name) {
  if (!cookiesAccepted) return null;
  const nameEQ = name + "=";
  const ca = document.cookie.split(';');
  for (let i = 0; i < ca.length; i++) {
    let c = ca[i];
    while (c.charAt(0) === ' ') c = c.substring(1, c.length);
    if (c.indexOf(nameEQ) === 0) {
      try {
        return JSON.parse(c.substring(nameEQ.length, c.length));
      } catch (e) {
        return null;
      }
    }
  }
  return null;
}

function checkGDPR() {
  // Check for consent cookie directly without using getCookie (which requires cookiesAccepted)
  const nameEQ = 'connecdoku_consent=';
  const ca = document.cookie.split(';');
  for (let i = 0; i < ca.length; i++) {
    let c = ca[i];
    while (c.charAt(0) === ' ') c = c.substring(1, c.length);
    if (c.indexOf(nameEQ) === 0) {
      try {
        const consent = JSON.parse(c.substring(nameEQ.length, c.length));
        cookiesAccepted = consent;
        return;
      } catch (e) {
        // Invalid cookie, continue
      }
    }
  }
  // No consent cookie found, show popup
  $('#gdprPop').classList.add('show');
}

/* ---------- statistics tracking ---------- */
let stats = {
  games: {}, // date -> strikes
  currentStreak: 0,
  longestStreak: 0,
  currentAttemptStreak: 0,
  longestAttemptStreak: 0,
  totalGames: 0,
  totalWins: 0
};

function loadStats() {
  const savedStats = getCookie('connecdoku_stats');
  if (savedStats) {
    stats = { ...stats, ...savedStats };
  }
}

function saveStats() {
  setCookie('connecdoku_stats', stats);
}

function updateStats(date, strikes, won) {
  stats.games[date] = strikes;
  stats.totalGames++;
  
  if (won) {
    stats.totalWins++;
    stats.currentStreak++;
    stats.currentAttemptStreak++;
    if (stats.currentStreak > stats.longestStreak) {
      stats.longestStreak = stats.currentStreak;
    }
    if (stats.currentAttemptStreak > stats.longestAttemptStreak) {
      stats.longestAttemptStreak = stats.currentAttemptStreak;
    }
  } else {
    stats.currentStreak = 0;
    stats.currentAttemptStreak++;
    if (stats.currentAttemptStreak > stats.longestAttemptStreak) {
      stats.longestAttemptStreak = stats.currentAttemptStreak;
    }
  }
  
  saveStats();
}

function getStrikeDistribution() {
  const distribution = [0, 0, 0, 0]; // 0, 1, 2, 3 strikes
  Object.values(stats.games).forEach(strikes => {
    if (strikes >= 0 && strikes <= 3) {
      distribution[strikes]++;
    }
  });
  return distribution;
}

/* ---------- load puzzle ---------- */
function loadGameState(currentPuzzle) {
  const savedState = getCookie('connecdoku_state');
  const currentDate = todayIdx();
  console.log('Current date index:', currentDate);
  console.log('Saved state date:', savedState ? savedState.date : 'none');
  if (savedState && savedState.date === currentDate) {
    // Additional validation: check if the saved state matches the current puzzle
    if (validateSavedState(savedState, currentPuzzle)) {
      return savedState;
    } else {
      console.log('Saved state validation failed - clearing invalid state');
      // Clear the invalid saved state
      setCookie('connecdoku_state', null, -1);
      return null;
    }
  }
  return null;
}

function validateSavedState(savedState, currentPuzzle) {
  if (!savedState || !currentPuzzle) return false;
  
  // Check if the saved state has the expected structure
  if (!savedState.grid || !Array.isArray(savedState.grid) || savedState.grid.length !== 4) {
    console.log('Saved state has invalid grid structure');
    return false;
  }
  
  // Flatten the current puzzle words and saved grid for comparison
  const currentWords = currentPuzzle.words.flat().sort();
  const savedWords = savedState.grid.flat().sort();
  
  // Check if all words match
  if (currentWords.length !== savedWords.length) {
    console.log('Word count mismatch:', currentWords.length, 'vs', savedWords.length);
    return false;
  }
  
  for (let i = 0; i < currentWords.length; i++) {
    if (currentWords[i] !== savedWords[i]) {
      console.log('Word mismatch at index', i, ':', currentWords[i], 'vs', savedWords[i]);
      return false;
    }
  }
  
  console.log('Saved state validation passed');
  return true;
}

function saveGameStateTemplate() {
  // This is a template - the actual function will be defined inside init()
  console.warn('saveGameState called before init');
}

// Initialize GDPR and stats
checkGDPR();
loadStats();

fetch('daily_puzzles/puzzles.json')
  .then(r=>r.json())
  .then(all=>init(all[todayIdx()%all.length]));

function init(puz){

  /* game vars - declare first so they can be accessed by loadGameState */
  let strikes=0, finished=false, sel=null;
  let solvedRows=new Map(), solvedCols=new Map(); // idx â†’ strike tier
  let G=[[],[],[],[]]; // board state

  const wordToColCat = {};          // use column labels
  const wordToRowCat = {};          // use row labels

  // add next to the other game-level variables
  let colCatToIdx = null;   // { column-category â†’ column # }
  let rowCatToIdx = null;   // { row-category    â†’ row #    }

  for (let r = 0; r < 4; r++) {
    for (let c = 0; c < 4; c++) {
      const w = puz.words[r][c];
      wordToRowCat[w] = puz.rows[r];    // category of its *row*
      wordToColCat[w] = puz.cols[c];    // category of its *column*
    }
  }

  // Try to load saved game state
  const savedState = loadGameState(puz);
  console.log('Loaded saved state:', savedState);
  if (savedState) {
    strikes = savedState.strikes;
    finished = savedState.finished;
    // Reconstruct Maps with proper values (strike levels)
    solvedRows = new Map();
    solvedCols = new Map();
    if (savedState.solvedRows && savedState.solvedRows.length > 0) {
      // New format: array of [key, value] pairs
      if (Array.isArray(savedState.solvedRows[0])) {
        savedState.solvedRows.forEach(([r, level]) => solvedRows.set(r, level));
        savedState.solvedCols.forEach(([c, level]) => solvedCols.set(c, level));
      } else {
        // Old format: just keys, use current strikes as level
        savedState.solvedRows.forEach(r => solvedRows.set(r, strikes));
        savedState.solvedCols.forEach(c => solvedCols.set(c, strikes));
      }
    } else if (savedState.solvedCols && savedState.solvedCols.length > 0) {
      // Handle case where only solvedCols has data
      if (Array.isArray(savedState.solvedCols[0])) {
        savedState.solvedCols.forEach(([c, level]) => solvedCols.set(c, level));
      } else {
        savedState.solvedCols.forEach(c => solvedCols.set(c, strikes));
      }
    }
    console.log('After loading - solvedRows:', solvedRows, 'solvedCols:', solvedCols);
    G = savedState.grid;
    sel = savedState.sel ? $(`.tile[data-rc="${savedState.sel}"]`) : null;
    
    // Show hint button if there are already strikes
    if (strikes >= 1) {
      $('#hintContainer').style.display = 'block';
    }
    
    // Validate the loaded state immediately
    setTimeout(() => {
      if (!validatePuzzleState()) {
        console.error('Loaded puzzle state is invalid - clearing and restarting');
        setCookie('connecdoku_state', null, -1);
        window.location.reload();
        return;
      }
      
      if (!validatePuzzleSolvability()) {
        console.error('Loaded puzzle state is unsolvable - showing popup');
        // The popup will be shown by validatePuzzleSolvability()
      }
    }, 100); // Small delay to ensure DOM is ready
  }

  /* answer lookup */
  const hash=a=>[...a].sort().join('|');
  const ans={};
  puz.rows.forEach((l,i)=>ans[hash(puz.words[i])]=l);
  for(let c=0;c<4;c++) ans[hash(puz.words.map(r=>r[c]))]=puz.cols[c];

  const rowIdx=Object.fromEntries(puz.rows.map((l,i)=>[l,i]));
  const colIdx=Object.fromEntries(puz.cols.map((l,i)=>[l,i]));

  /* board state */
  if (!savedState) {
    // Only shuffle and initialize if we don't have saved state
  const flat=[...puz.words.flat()].map(v=>[Math.random(),v])
               .sort((a,b)=>a[0]-b[0]).map(v=>v[1]);
    let k=0;
  for(let r=0;r<4;r++)for(let c=0;c<4;c++)G[r][c]=flat[k++];
  }

  /* dynamic canonical maps (created on first solve) */
  let colPos=null; // word â†’ target column   (defined when first row category solved)
  let rowPos=null; // word â†’ target row      (defined when first column category solved)

  // Define saveGameState function inside init scope
  function saveGameState() {
    const state = {
      date: todayIdx(),
      strikes: strikes,
      finished: finished,
      solvedRows: Array.from(solvedRows.entries()),
      solvedCols: Array.from(solvedCols.entries()),
      grid: G,
      sel: sel ? sel.dataset.rc : null
    };
    console.log('Saving state:', state);
    setCookie('connecdoku_state', state);
  }

  renderBoard(); updateStrike();
  
  // Save state periodically and on key events
  setInterval(saveGameState, 30000); // Save every 30 seconds

  /* ------------------------------------------------------------
    relabelAllHeaders()  â€“  hash-based, orientation-agnostic
    â€¢ Works after solveCompletely() finishes (every line is a set)
    â€¢ Reads the category from the *whole 4-word line*
    â€¢ Leaves solved headers untouched; greys unsolved ones
  ---------------------------------------------------------------- */
  function relabelAllHeaders() {
    const hash = a => [...a].sort().join('|');

    /* â”€â”€ rows â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
    for (let r = 0; r < 4; r++) {
      if (solvedRows.has(r)) continue;

      const hdr = document.querySelector(`.hdr[data-row="${r}"]`);
      if (!hdr) continue;

      const label = ans[hash(G[r])];
      if (label) {
        hdr.textContent = label;
        hdr.classList.add('emoji'); // Add emoji class for compound emoji support
      } else {
        hdr.textContent = 'â“';
        hdr.classList.add('emoji'); // Add emoji class for compound emoji support
        console.warn(
          `Row ${r}: [${G[r].join(', ')}] â†’ these four words don't make a category`
        );
      }
      hdr.classList.add('disabled');
      hdr.style.color = '#666';
    }

    /* â”€â”€ columns â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
    for (let c = 0; c < 4; c++) {
      if (solvedCols.has(c)) continue;

      const hdr = document.querySelector(`.hdr[data-col="${c}"]`);
      if (!hdr) continue;

      const colWords = [G[0][c], G[1][c], G[2][c], G[3][c]];
      const label = ans[hash(colWords)];
      if (label) {
        hdr.textContent = label;
        hdr.classList.add('emoji'); // Add emoji class for compound emoji support
      } else {
        hdr.textContent = 'â“';
        hdr.classList.add('emoji'); // Add emoji class for compound emoji support
        console.warn(
          `Col ${c}: [${colWords.join(', ')}] â†’ these four words don't make a category`
        );
      }
      hdr.classList.add('disabled');
      hdr.style.color = '#666';
    }
  }

  /* ---------- DOM ---------- */
  function renderBoard(){
    const bd=$('#board'); bd.innerHTML='';
    for(let c=0;c<4;c++) bd.appendChild(makeHdr('col',c));
    bd.appendChild(document.createElement('div'));
    for(let r=0;r<4;r++){
      for(let c=0;c<4;c++) bd.appendChild(makeTile(r,c));
      bd.appendChild(makeHdr('row',r));
    }
  }
  function makeTile(r,c){
    const d=document.createElement('div');
    d.className='tile'; d.textContent=G[r][c]; d.dataset.rc=`${r},${c}`;
    return d;
  }
  function makeHdr(kind,idx){
    const d=document.createElement('div');
    d.className='hdr clickHdr'; d.dataset[kind]=idx;
    d.innerHTML='<button>âœ“</button>'; return d;
  }
  const tile=(r,c)=>$(`.tile[data-rc="${r},${c}"]`);
  const lockColour=(r,c,lvl)=>{
    const t=tile(r,c);
    // Only apply color if it's better (lower strike count) than existing
    const hasBetter=t.classList.contains('lock0')||(lvl>0&&t.classList.contains('lock1'))||(lvl>1&&t.classList.contains('lock2'));
    if(!hasBetter) t.classList.add(clr[lvl]);
  };
  
  /* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    freezeTile(r,c)  â€“ v2
    â€¢ Marks the tile as frozen
    â€¢ Guarantees a frozen tile can never remain selected
    â€¢ Clears the global `sel` pointer when necessary
  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
  const freezeTile = (r, c) => {
    const t = tile(r, c);
    if (!t) return;

    t.classList.add('frozen');

    if (t.classList.contains('selected')) {
      t.classList.remove('selected');
      if (sel === t) sel = null;
    }
  };

  // return a string like "StarWars|Pokemon|Fruits|Cities"
  function categorySignature(words) {
    return words     // words = 4-item array
      .map(w => ans[[...w].sort().join('|')])  // look up its category
      .join('|');
  }

  /* ---------- click handling ---------- */
  $('#board').addEventListener('click',e=>{
    if(finished) return;
    const t=e.target.closest('.tile');
    const h=e.target.closest('.clickHdr');
    if(t && !t.classList.contains('frozen')) handleTileClick(t);
    if(h){
      const r=h.dataset.row!==undefined?+h.dataset.row:null;
      const c=h.dataset.col!==undefined?+h.dataset.col:null;
      if(r!==null) checkLine('row',r,h);
      if(c!==null) checkLine('col',c,h);
    }
  });

  function handleTileClick(td){
    if(sel===td){ td.classList.remove('selected'); sel=null; return; }
    if(!sel){ td.classList.add('selected'); sel=td; return; }

    const [r1,c1]=sel.dataset.rc.split(',').map(Number);
    const [r2,c2]=td.dataset.rc.split(',').map(Number);
    if(solvedRows.has(r1)||solvedRows.has(r2)||solvedCols.has(c1)||solvedCols.has(c2)) return;
    
    // Clear selection immediately
    sel.classList.remove('selected'); 
    const oldSel = sel;
    sel = null;
    
    swapCells(r1,c1,r2,c2,true);
    
    // Ensure selection is cleared after animation
    setTimeout(() => {
      if (oldSel) oldSel.classList.remove('selected');
    }, 500);

    integrityCheck();
  }

  /* ---------- solving logic ---------- */
  function checkLine(kind,idx,hdr,auto=false){
    if(hdr.classList.contains('solved')) return;

    if(!auto && (
      (kind==='row'&&solvedRows.size>=3&&solvedCols.size<4)||
      (kind==='col'&&solvedCols.size>=3&&solvedRows.size<4))) return;

    const words=kind==='row'?G[idx]:G.map(r=>r[idx]);
    const label=ans[hash(words)];
    if(!label) return badAttempt(hdr);
    
    console.log(`Solved ${kind} ${idx} as category: "${label}"`);

    /* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ first *row-category* solved â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
    if (colCatToIdx === null && rowIdx[label] !== undefined) {
      // Whether we just solved a *row* or a *column* doesnâ€™t matter.
      // We only care that `label` belongs to puz.rows â†’ its line shows
      // us the order of the four *column* categories.
      colCatToIdx = {};

      if (kind === 'row') {
        // row solved horizontally : categories vary left â†’ right
        for (let c = 0; c < 4; c++) {
          const cat = wordToColCat[G[idx][c]];
          colCatToIdx[cat] = c;
        }
      } else {
        // row-category solved vertically (transpose case)
        for (let r = 0; r < 4; r++) {
          const cat = wordToColCat[G[r][idx]];
          colCatToIdx[cat] = r;    // here the *row* index is the x-coord
        }
      }
    }

    /* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ first *column-category* solved â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
    if (rowCatToIdx === null && colIdx[label] !== undefined) {
      rowCatToIdx = {};

      if (kind === 'col') {
        // column solved vertically : row categories vary top â†’ bottom
        for (let r = 0; r < 4; r++) {
          const cat = wordToRowCat[G[r][idx]];
          rowCatToIdx[cat] = r;
        }
      } else {
        // column-category solved horizontally (transpose case)
        for (let c = 0; c < 4; c++) {
          const cat = wordToRowCat[G[idx][c]];
          rowCatToIdx[cat] = c;    // column index is the y-coord here
        }
      }
    }

    /* ---- update UI ---- */
    const lvl=strikes;
    const solved=kind==='row'?solvedRows:solvedCols;
    
    // Check if we should align before adding the current solve
    const shouldAlign = (kind === 'row' && solvedRows.size >= 1) || (kind === 'col' && solvedCols.size >= 1);
    
    if(shouldAlign) {
      console.log(`Aligning ${kind} ${idx}, solvedRows: ${solvedRows.size}, solvedCols: ${solvedCols.size}`);
      if(kind==='row') alignRow(idx);
      if(kind==='col') alignCol(idx);
    } else {
      console.log(`Not aligning ${kind} ${idx}, solvedRows: ${solvedRows.size}, solvedCols: ${solvedCols.size}`);
    }
    
    hdr.replaceWith(makeSolvedLabel(label,lvl));
    solved.set(idx,lvl);
    colourAndFreeze(kind,idx,lvl);

    freezeIntersections();
    if((kind==='row'&&solvedRows.size===3)||(kind==='col'&&solvedCols.size===3))
      disableSameHeaders(kind);

    if(!finished) autoEndIfObvious();
    if(solvedRows.size===4&&solvedCols.size===4) finish(true);

    saveGameState();
    integrityCheck();
    validatePuzzleState();
    validatePuzzleSolvability();
  }

  function makeSolvedLabel(txt,lvl){
    const d=document.createElement('div');
    d.className=`hdr solved ${clr[lvl]} pop emoji`; d.textContent=txt; return d;
  }
  const colourAndFreeze=(k,i,l)=>{
    if(k==='row') for(let c=0;c<4;c++){ lockColour(i,c,l); freezeTile(i,c); }
    else          for(let r=0;r<4;r++){ lockColour(r,i,l); freezeTile(r,i); }
  };

  /* -----------------------------------------------
    alignRow(r)  â€“ put every movable word in row r
                    into the column fixed for *its*
                    column-category.
    --------------------------------------------- */
  function alignRow(r) {
    if (!colCatToIdx && !rowCatToIdx) return; // no mappings yet

    console.log(`Aligning row ${r}:`, G[r]);
    console.log('Column category mapping:', colCatToIdx);
    console.log('Row category mapping:', rowCatToIdx);
    
    // Check if this row contains column categories (transposed case)
    const rowCategories = G[r].map(w => ({
      word: w,
      rowCat: wordToRowCat[w],
      colCat: wordToColCat[w]
    }));
    const uniqueRowCats = new Set(rowCategories.map(item => item.rowCat));
    const uniqueColCats = new Set(rowCategories.map(item => item.colCat));
    
    // A row is transposed if it has multiple column categories but only one row category
    // (indicating it's a row category that contains column categories)
    const isTransposedRow = uniqueColCats.size > 1 && uniqueRowCats.size === 1;
    
    console.log(`Row appears to be ${isTransposedRow ? 'transposed (contains column categories)' : 'normal (contains row categories)'}`);
    console.log(`Row word categories:`, rowCategories);
    console.log(`Unique row categories: ${Array.from(uniqueRowCats).join(', ')}`);
    console.log(`Unique column categories: ${Array.from(uniqueColCats).join(', ')}`);
    console.log(`Row category count: ${uniqueRowCats.size}, Column category count: ${uniqueColCats.size}`);
    
    // Instead of trying every possible move, let's be more strategic
    // Only make moves that improve the alignment toward a valid solution
    
    let moved;
    let attempts = 0;
    const maxAttempts = 20; // Circuit breaker to prevent infinite loops
    
    do {
      moved = false;
      attempts++;
      
      if (attempts > maxAttempts) {
        console.warn(`Alignment loop detected for row ${r}, stopping after ${maxAttempts} attempts`);
        break;
      }
      
      // For each word in this row, check if it's in the right category column
      for (let c = 0; c < 4; c++) {
        if (solvedCols.has(c)) continue; // Can't move words in solved columns
        
        const w = G[r][c];
        const wordCategory = wordToColCat[w];
        
        // Check if this word is in the right column for its category
        // (based on the canonical mapping we learned from solved lines)
        let canonicalCol = colCatToIdx ? colCatToIdx[wordCategory] : undefined;
        
        console.log(`Word "${w}" has column category "${wordCategory}", canonical col: ${canonicalCol}`);
        
        // If we don't have column mappings but we have row mappings, 
        // we might be in a transposed situation where row categories are actually column categories
        if (canonicalCol === undefined && rowCatToIdx) {
          // Check if this word belongs to a row category that we've mapped
          const rowCategory = wordToRowCat[w];
          const mappedRow = rowCatToIdx[rowCategory];
          if (mappedRow !== undefined) {
            // In transposed case, row position maps to column position
            canonicalCol = mappedRow;
            console.log(`Using transposed mapping: "${w}" (row category "${rowCategory}") -> col ${canonicalCol}`);
          }
        }
        
        // Additional check: if we're aligning a row and have both mappings,
        // we might need to use the column mapping for transposed cases
        if (canonicalCol === undefined && colCatToIdx && rowCatToIdx) {
          // This could be a case where we're aligning a row that contains column categories
          const colCategory = wordToColCat[w];
          const mappedCol = colCatToIdx[colCategory];
          if (mappedCol !== undefined) {
            canonicalCol = mappedCol;
          }
        }
        
        if (canonicalCol !== undefined && canonicalCol !== c && !solvedCols.has(canonicalCol)) {
          // This word should be in a different column
          console.log(`Moving "${w}" from column ${c} to canonical column ${canonicalCol}`);
          
          console.log(`Executing move: "${w}" from column ${c} to column ${canonicalCol}`);
          swapCells(r, c, r, canonicalCol, true);
          moved = true;
          break; // Only make one move at a time to avoid loops
        }
      }
    } while (moved);

    console.log(`Row ${r} after alignment:`, G[r]);
    integrityCheck();
  }

  /* -----------------------------------------------
    alignCol(c)  â€“ put every movable word in col c
                    into the row fixed for *its*
                    row-category.
    --------------------------------------------- */
  function alignCol(c) {
    if (!rowCatToIdx && !colCatToIdx) return; // no mappings yet

    console.log(`Aligning column ${c}:`, [G[0][c], G[1][c], G[2][c], G[3][c]]);
    console.log('Row category mapping:', rowCatToIdx);
    console.log('Column category mapping:', colCatToIdx);
    
    // Debug: show what categories are in this column
    const colCategories = [G[0][c], G[1][c], G[2][c], G[3][c]].map(w => ({
      word: w,
      rowCat: wordToRowCat[w],
      colCat: wordToColCat[w]
    }));
    console.log('Column categories:', colCategories);
    
    // Check if this column contains row categories (transposed case)
    const uniqueRowCats = new Set(colCategories.map(item => item.rowCat));
    const uniqueColCats = new Set(colCategories.map(item => item.colCat));
    
    // If all words have the same row category, it's likely transposed
    const isTransposedColumn = uniqueRowCats.size === 1 && uniqueRowCats.size < uniqueColCats.size;
    
    console.log(`Column appears to be ${isTransposedColumn ? 'transposed (contains row categories)' : 'normal (contains column categories)'}`);
    console.log(`Unique row categories: ${Array.from(uniqueRowCats).join(', ')}`);
    console.log(`Unique column categories: ${Array.from(uniqueColCats).join(', ')}`);
    
    // Instead of trying every possible move, let's be more strategic
    // Only make moves that improve the alignment toward a valid solution
    
    let moved;
    let attempts = 0;
    const maxAttempts = 20; // Circuit breaker to prevent infinite loops
    
    do {
      moved = false;
      attempts++;
      
      if (attempts > maxAttempts) {
        console.warn(`Alignment loop detected for column ${c}, stopping after ${maxAttempts} attempts`);
        break;
      }
      
      // For each word in this column, check if it's in the right category row
      for (let r = 0; r < 4; r++) {
        if (solvedRows.has(r)) continue; // Can't move words in solved rows
        
        const w = G[r][c];
        const wordCategory = wordToRowCat[w];
        
        // Check if this word is in the right row for its category
        // (based on the canonical mapping we learned from solved lines)
        let canonicalRow = rowCatToIdx ? rowCatToIdx[wordCategory] : undefined;
        
        console.log(`Word "${w}" has row category "${wordCategory}", canonical row: ${canonicalRow}`);
        
        // If we don't have row mappings but we have column mappings, 
        // we might be in a transposed situation where column categories are actually row categories
        if (canonicalRow === undefined && colCatToIdx) {
          // Check if this word belongs to a column category that we've mapped
          const colCategory = wordToColCat[w];
          const mappedCol = colCatToIdx[colCategory];
          if (mappedCol !== undefined) {
            // In transposed case, column position maps to row position
            canonicalRow = mappedCol;
            console.log(`Using transposed mapping: "${w}" (col category "${colCategory}") -> row ${canonicalRow}`);
          }
        }
        
        // Additional check: if we're aligning a column and have both mappings,
        // we might need to use the row mapping for transposed cases
        if (canonicalRow === undefined && rowCatToIdx && colCatToIdx) {
          // This could be a case where we're aligning a column that contains row categories
          const rowCategory = wordToRowCat[w];
          const mappedRow = rowCatToIdx[rowCategory];
          if (mappedRow !== undefined) {
            canonicalRow = mappedRow;
            console.log(`Using row mapping for column alignment: "${w}" (row category "${rowCategory}") -> row ${canonicalRow}`);
          }
        }
        
        // Special case: if we're aligning a column that was just solved and it's a row category,
        // we should prioritize using the row category mapping over the column category mapping
        if (canonicalRow === undefined && rowCatToIdx) {
          const rowCategory = wordToRowCat[w];
          const mappedRow = rowCatToIdx[rowCategory];
          if (mappedRow !== undefined) {
            canonicalRow = mappedRow;
            console.log(`Using row mapping for transposed column: "${w}" (row category "${rowCategory}") -> row ${canonicalRow}`);
          }
        }
        
        // If this is a transposed column, prioritize row category mapping
        if (isTransposedColumn && canonicalRow === undefined && rowCatToIdx) {
          const rowCategory = wordToRowCat[w];
          const mappedRow = rowCatToIdx[rowCategory];
          if (mappedRow !== undefined) {
            canonicalRow = mappedRow;
            console.log(`Using row mapping for detected transposed column: "${w}" (row category "${rowCategory}") -> row ${canonicalRow}`);
          }
        }
        
        if (canonicalRow !== undefined && canonicalRow !== r && !solvedRows.has(canonicalRow)) {
          // This word should be in a different row
          console.log(`Moving "${w}" from row ${r} to canonical row ${canonicalRow}`);
          
          swapCells(r, c, canonicalRow, c, true);
          moved = true;
          break; // Only make one move at a time to avoid loops
        }
      }
    } while (moved);

    console.log(`Column ${c} after alignment:`, [G[0][c], G[1][c], G[2][c], G[3][c]]);
    integrityCheck();
  }

  function freezeIntersections(){
    for(const r of solvedRows.keys())
      for(const c of solvedCols.keys()) freezeTile(r,c);
  }

  function disableSameHeaders(kind){
    const solvedMap=kind==='row'?solvedRows:solvedCols;
    for(let i=0;i<4;i++){
      if(solvedMap.has(i)) continue;
      const hdr=$(`.hdr[data-${kind}="${i}"]`);
      if(hdr){ 
        hdr.classList.add('disabled'); 
        hdr.innerHTML=''; 
        // Make the last unsolved header more visually obvious
        if(solvedMap.size === 3) {
          hdr.style.background = '#ffeb3b';
          hdr.style.color = '#333';
          hdr.style.fontWeight = 'bold';
          hdr.style.border = '2px solid #ffc107';
        }
      }
    }
    checkAutoSolve();
  }

  function checkAutoSolve(){
    if(solvedRows.size+solvedCols.size!==6) return;
    const r=[0,1,2,3].find(i=>!solvedRows.has(i));
    const c=[0,1,2,3].find(i=>!solvedCols.has(i));
    
    // With 6 solved lines, the last row and column must already be correct
    // No need to rearrange - just auto-solve the remaining headers
    setTimeout(()=>{
      const rh=$(`.hdr[data-row="${r}"]`);
      const ch=$(`.hdr[data-col="${c}"]`);
      if(rh) checkLine('row',r,rh,true);
      if(ch) checkLine('col',c,ch,true);
    },100);
  }

  /* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ strikes / misc â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
  function badAttempt(hdr) {

    /* mark header, add strike, shake */
    if (strikes < 3) {
    strikes++;
    hdr.classList.add(strikes === 1 ? 'used1' : 'used2');
    shake();
    updateStrike();
    saveGameState();

    // Show hint button after first strike
    if (strikes === 1) {
      $('#hintContainer').style.display = 'block';
    }

    /* third strike â‡’ auto-solve, reveal labels, end game */
      if (strikes >= 3) {

      // put every word in its true final position
      const animTime = solveCompletely();   // may be 0 ms if nothing moved

      // after swaps finish, show missing headers & freeze board
      setTimeout(() => {
        relabelAllHeaders();
        finish(false);
      }, 1000 + animTime);                  // 1 s pause + animation
      }
    }
  }


  function updateStrike(){ $('#strikeTxt').textContent=`Strikes ${strikes}/3`; }
  const shake=()=>{ $('#shell').classList.add('shake');
                    setTimeout(()=>$('#shell').classList.remove('shake'),1200); };

  /* -------------------------------------------------
    swapCells(r1, c1, r2, c2, animate = false, animOnly = false)
    ----------------------------------------------------------- */
  function swapCells(r1, c1, r2, c2, animate = false, animOnly = false) {
    if (r1 === r2 && c1 === c2) return;

    const t1 = tile(r1, c1);
    const t2 = tile(r2, c2);
    if (!t1 || !t2) return;

    /* â”€â”€ visual animation â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
    if (animate) {
      const a = t1.getBoundingClientRect();
      const b = t2.getBoundingClientRect();
      const dx = b.left - a.left;
      const dy = b.top - a.top;
      const opt = { duration: 500, easing: 'cubic-bezier(.4,0,.2,1)' };

      t1.animate([{ transform: `translate(${dx}px,${dy}px)` }, { transform: 'none' }], opt);
      t2.animate([{ transform: `translate(${-dx}px,${-dy}px)` }, { transform: 'none' }], opt);

      /* update the text **after** the slide completes so it looks natural */
      setTimeout(() => {
        t1.textContent = G[r1][c1];
        t2.textContent = G[r2][c2];
      }, opt.duration);
    }

    /* â”€â”€ logical swap (unless weâ€™re only animating) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
    if (!animOnly) {
      [G[r1][c1], G[r2][c2]] = [G[r2][c2], G[r1][c1]];
      [t1.textContent, t2.textContent] = [t2.textContent, t1.textContent];
      integrityCheck();
    }
  }

  function autoEndIfObvious(){
    if(solvedRows.size===3&&solvedCols.size<4){
      const r=[0,1,2,3].find(i=>!solvedRows.has(i));
      checkLine('row',r,$(`.hdr[data-row="${r}"]`));
    }else if(solvedCols.size===3&&solvedRows.size<4){
      const c=[0,1,2,3].find(i=>!solvedCols.has(i));
      checkLine('col',c,$(`.hdr[data-col="${c}"]`));
    }
  }

  function finish(won) {
    finished = true;

    // just freeze everything; leave the current board text untouched
    for (let r = 0; r < 4; r++)
      for (let c = 0; c < 4; c++)
        freezeTile(r, c);

    // Hide hint button when game is finished
    $('#hintContainer').style.display = 'none';

    // Update statistics
    const today = new Date().toISOString().split('T')[0];
    updateStats(today, strikes, won);

    setTimeout(() => {
      showShare(won);
      $('#shareBtn').style.display = 'block';
    }, 600);

    integrityCheck();
  }

  /* ------------------------------------------------------------
    getOrientation()
    â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    Inspect the *first* solved line (row or column). If its
    category lives in puz.rows => normal orientation,
    otherwise we treat the puzzle as transposed.
  ---------------------------------------------------------------- */
  function getOrientation() {
    if (solvedRows.size) {
      const r   = [...solvedRows.keys()][0];
      const cat = ans[hash(G[r])];                 // category of that row
      return puz.rows.includes(cat) ? 'normal' : 'transposed';
    }
    if (solvedCols.size) {
      const c   = [...solvedCols.keys()][0];
      const cat = ans[hash(G.map(r => r[c]))];     // category of that col
      return puz.cols.includes(cat) ? 'normal' : 'transposed';
    }
    return 'normal';                               // fallback until something is solved
  }

  /* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ integrity guard v3 â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
  const solvedPositions = new Map();   // word â†’ { r, c }

  function integrityCheck() {
    /* 1-a. solved words may never move */
    for (let r = 0; r < 4; r++) {
      for (let c = 0; c < 4; c++) {
        if (!solvedRows.has(r) && !solvedCols.has(c)) continue;
        const w   = G[r][c];
        const pos = solvedPositions.get(w);
        if (!pos) solvedPositions.set(w, { r, c });
        else if (pos.r !== r || pos.c !== c) {
          throw new Error(`Solved word "${w}" moved from [${pos.r},${pos.c}] to [${r},${c}]`);
        }
      }
    }

    /* 1-b. every fully-solved line must hash to a known category */
    const hash = a => [...a].sort().join('|');
    for (const r of solvedRows.keys()) {
      if (!ans[hash(G[r])]) throw new Error(`Row ${r} claims solved but is not a valid set`);
    }
    for (const c of solvedCols.keys()) {
      const col = [G[0][c], G[1][c], G[2][c], G[3][c]];
      if (!ans[hash(col)]) throw new Error(`Column ${c} claims solved but is not a valid set`);
    }
  }

  function validatePuzzleState() {
    console.log('=== PUZZLE STATE VALIDATION ===');
    
    // Check if all words are still present
    const allWords = new Set();
    for (let r = 0; r < 4; r++) {
      for (let c = 0; c < 4; c++) {
        allWords.add(G[r][c]);
      }
    }
    
    const expectedWords = new Set(puz.words.flat());
    if (allWords.size !== expectedWords.size) {
      console.error('Word count mismatch!', allWords.size, 'vs', expectedWords.size);
      return false;
    }
    
    for (const word of expectedWords) {
      if (!allWords.has(word)) {
        console.error('Missing word:', word);
        return false;
      }
    }
    
    // Check alignment maps
    if (colCatToIdx) {
      console.log('Column category mapping:', colCatToIdx);
    }
    if (rowCatToIdx) {
      console.log('Row category mapping:', rowCatToIdx);
    }
    
    // Check solved state
    console.log('Solved rows:', Array.from(solvedRows.keys()));
    console.log('Solved cols:', Array.from(solvedCols.keys()));
    
    // Validate that solved lines are actually correct
    const hash = a => [...a].sort().join('|');
    for (const r of solvedRows.keys()) {
      const rowWords = G[r];
      const category = ans[hash(rowWords)];
      if (!category) {
        console.error(`Row ${r} claims solved but doesn't match any category:`, rowWords);
        return false;
      }
      console.log(`Row ${r} solved as:`, category);
    }
    
    for (const c of solvedCols.keys()) {
      const colWords = [G[0][c], G[1][c], G[2][c], G[3][c]];
      const category = ans[hash(colWords)];
      if (!category) {
        console.error(`Column ${c} claims solved but doesn't match any category:`, colWords);
        return false;
      }
      console.log(`Column ${c} solved as:`, category);
    }
    
    console.log('Puzzle state validation passed');
    return true;
  }

  function showUnsolvablePopup() {
    // Only show the popup if it's not already showing and the game isn't finished
    if (!finished && !document.getElementById('unsolvablePop').classList.contains('show')) {
      $('#unsolvablePop').classList.add('show');
    }
  }

  function validatePuzzleSolvability() {
    console.log('=== CHECKING PUZZLE SOLVABILITY ===');
    
    const hash = a => [...a].sort().join('|');
    const isFrozen = (r, c) => solvedRows.has(r) || solvedCols.has(c);

    /* â”€â”€ helper: generate all 24 permutations of [0,1,2,3] â”€â”€â”€â”€â”€â”€â”€ */
    function allPerms() {
      const res = [];
      function perm(a, l) {
        if (l === 4) res.push(a.slice());
        else for (let i = l; i < 4; i++) {
          [a[l], a[i]] = [a[i], a[l]];
          perm(a, l + 1);
          [a[l], a[i]] = [a[i], a[l]];
              }
        }
      perm([0, 1, 2, 3], 0);
      return res;
    }
    const PERMS = allPerms();               // cached once

    /* â”€â”€ build the two "base" grids: normal & transposed â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
    const BASE_NORMAL = puz.words;          // rows = row categories
    const BASE_TRANS  = Array.from({ length: 4 }, (_, r) =>
                            Array.from({ length: 4 }, (_, c) => puz.words[c][r]));

    /* â”€â”€ try every orientation / row-perm / col-perm combo â”€â”€â”€â”€â”€â”€â”€ */
    let foundValidSolution = false;

    outer: for (const base of [BASE_NORMAL, BASE_TRANS]) {
      for (const rows of PERMS) {
        for (const cols of PERMS) {

          /* quick reject: must respect every frozen word */
          let ok = true;
          for (let r = 0; r < 4 && ok; r++) {
            for (let c = 0; c < 4 && ok; c++) {
              if (!isFrozen(r, c)) continue;
              const want = base[rows[r]][cols[c]];
              if (G[r][c] !== want) ok = false;
            }
          }
          if (!ok) continue;

          /* this candidate fits all anchors â†’ puzzle is solvable */
          foundValidSolution = true;
            console.log('Found valid solution with permutation:', { rows, cols });
            break outer;
          }
        }
      }

    if (foundValidSolution) {
      console.log('âœ… Puzzle is solvable');
      return true;
    } else {
      console.error('âŒ Puzzle is NOT solvable - no valid permutation found');
      showUnsolvablePopup();
      return false;
    }
  }

  /* ------------------------------------------------------------
    solveCompletely()  â€“  v7  (â€œbrute-force like a humanâ€)
    -----------------------------------------------------------
    â€¢ A valid Connecdoku grid is just the canonical puzzle grid
      after (optional) transpose + a permutation of its rows +
      a permutation of its columns  â†’  2 Ã— 24 Ã— 24 = 1 152.
    â€¢ For each candidate grid:
        â€“ all words in already-solved rows/cols must match
        â€“ otherwise skip
      The first match becomes the target.  We then swap every
      non-frozen tile into its target square and animate the lot.
  ------------------------------------------------------------ */
  function solveCompletely() {

    const hash = a => [...a].sort().join('|');
    const isFrozen = (r, c) => solvedRows.has(r) || solvedCols.has(c);

    /* â”€â”€ helper: generate all 24 permutations of [0,1,2,3] â”€â”€â”€â”€â”€â”€â”€ */
    function allPerms() {
      const res = [];
      function perm(a, l) {
        if (l === 4) res.push(a.slice());
        else for (let i = l; i < 4; i++) {
          [a[l], a[i]] = [a[i], a[l]];
          perm(a, l + 1);
          [a[l], a[i]] = [a[i], a[l]];
              }
        }
      perm([0, 1, 2, 3], 0);
      return res;
    }
    const PERMS = allPerms();               // cached once

    /* â”€â”€ build the two â€œbaseâ€ grids: normal & transposed â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
    const BASE_NORMAL = puz.words;          // rows = row categories
    const BASE_TRANS  = Array.from({ length: 4 }, (_, r) =>
                            Array.from({ length: 4 }, (_, c) => puz.words[c][r]));

    /* â”€â”€ try every orientation / row-perm / col-perm combo â”€â”€â”€â”€â”€â”€â”€ */
    let target = null;

    outer: for (const base of [BASE_NORMAL, BASE_TRANS]) {
      for (const rows of PERMS) {
        for (const cols of PERMS) {

          /* quick reject: must respect every frozen word */
          let ok = true;
          for (let r = 0; r < 4 && ok; r++) {
            for (let c = 0; c < 4 && ok; c++) {
              if (!isFrozen(r, c)) continue;
              const want = base[rows[r]][cols[c]];
              if (G[r][c] !== want) ok = false;
            }
          }
          if (!ok) continue;

          /* this candidate fits all anchors â†’ accept */
          target = Array.from({ length: 4 }, (_, r) =>
                    Array.from({ length: 4 }, (_, c) =>
                      base[rows[r]][cols[c]]));
          break outer;
        }
      }
    }

    /* fallback (should never happen) */
    if (!target) {
      console.warn('solveCompletely: no compatible layout found â€“ falling back');
      return 0;
    }

    /* â”€â”€ plan swaps from current grid â†’ target grid â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
    const locate = new Map();                    // word â†’ [r,c]
    for (let r = 0; r < 4; r++)
      for (let c = 0; c < 4; c++)
        locate.set(G[r][c], [r, c]);

    const moves = [];

    for (let r = 0; r < 4; r++) {
      for (let c = 0; c < 4; c++) {

        if (isFrozen(r, c)) continue;

        const want = target[r][c];
        if (G[r][c] === want) continue;

        const [r2, c2] = locate.get(want);
        if (isFrozen(r2, c2)) continue;          // shouldnâ€™t happen

        moves.push([r, c, r2, c2]);

        /* update virtual grid + locator */
        locate.set(G[r][c], [r2, c2]);
        locate.set(want,    [r , c ]);
        [G[r][c], G[r2][c2]] = [G[r2][c2], G[r][c]];
      }
    }

    /* â”€â”€ animate (logical swaps already done) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
    moves.forEach((m, i) =>
      setTimeout(() => swapCells(m[0], m[1], m[2], m[3], true, true), i * 100)
    );

    return moves.length * 100;         // total animation time
  }

  /* ---------- share popup ---------- */
  let categoryEmojis = {};
  
  // Load category emojis
  fetch('data/category_emojis.json')
    .then(r => r.json())
    .then(data => { categoryEmojis = data; })
    .catch(err => console.warn('Could not load category emojis:', err));

  function emojiFor(td){ return td.classList.contains('lock0')?emj[0]:
                               td.classList.contains('lock1')?emj[1]:
                               td.classList.contains('lock2')?emj[2]:'â¬›'; }
  
  function getCategoryEmoji(category) {
    return categoryEmojis[category] || 'â“';
  }
  
  function getPuzzleCategoryEmojis() {
    // Get the 4 row categories and 4 column categories from the puzzle
    const rowEmojis = puz.rows.map(category => getCategoryEmoji(category));
    const colEmojis = puz.cols.map(category => getCategoryEmoji(category));
    
    // Return all 8 emojis in the order they appear in the final grid
    // (column categories first, then row categories)
    return colEmojis.join('') + rowEmojis.join('');
  }
  
  function createEmojiGrid() {
    const hash = a => [...a].sort().join('|');
    const rows = [];
    const cols = [];
    
    // Get row categories (either solved or current state)
    for (let r = 0; r < 4; r++) {
      if (solvedRows.has(r)) {
        // Use the solved category
        const cat = ans[hash(G[r])];
        rows.push(getCategoryEmoji(cat));
      } else {
        // Use current state to determine category
        const cat = ans[hash(G[r])];
        rows.push(getCategoryEmoji(cat));
      }
    }
    
    // Get column categories (either solved or current state)
    for (let c = 0; c < 4; c++) {
      if (solvedCols.has(c)) {
        // Use the solved category
        const colWords = [G[0][c], G[1][c], G[2][c], G[3][c]];
        const cat = ans[hash(colWords)];
        cols.push(getCategoryEmoji(cat));
      } else {
        // Use current state to determine category
        const colWords = [G[0][c], G[1][c], G[2][c], G[3][c]];
        const cat = ans[hash(colWords)];
        cols.push(getCategoryEmoji(cat));
      }
    }
    
    // Create the grid with title
    const today = new Date();
    const dateStr = today.toISOString().split('T')[0].replace(/-/g, '-');
    let grid = `Connecdoku ${dateStr}\n\n`;
    grid += cols.join('') + '\n';  // Column categories at top
    for (let r = 0; r < 4; r++) {
      let row = '';
      for (let c = 0; c < 4; c++) {
        row += emojiFor(tile(r, c));
      }
      row += rows[r];  // Row category at end of each row
      grid += row + '\n';
    }
    
    return grid;
  }
  
  function getCustomTitle(won, strikes) {
    if (won) {
      if (strikes === 0) {
        const messages = ["ğŸ‰ Amazing!", "ğŸŠ Perfect!", "ğŸŒŸ Flawless!", "âœ¨ Incredible!", "ğŸ† Masterpiece!"];
        return messages[Math.floor(Math.random() * messages.length)];
      } else if (strikes === 1) {
        const messages = ["Good job!", "Well done!", "Nice work!", "Great solve!", "Solid performance!"];
        return messages[Math.floor(Math.random() * messages.length)];
      } else if (strikes === 2) {
        const messages = ["Phew! Close one.", "That was tight!", "Just made it!", "Narrow escape!", "Cutting it close!"];
        return messages[Math.floor(Math.random() * messages.length)];
      }
    } else {
      if (strikes === 3) {
        const solvedCount = solvedRows.size + solvedCols.size;
        if (solvedCount === 0) {
          const messages = ["ğŸ¤¦â€â™‚ï¸ Maybe try again?", "ğŸ˜… That was... something.", "ğŸ¤·â€â™‚ï¸ At least you tried?", "ğŸ’€ Brutal."];
          return messages[Math.floor(Math.random() * messages.length)];
        } else {
          const messages = ["You'll beat it next time!", "Good try!", "Almost had it!", "Better luck next time!", "Keep practicing!"];
          return messages[Math.floor(Math.random() * messages.length)];
  }
      }
    }
    return "Connecdoku"; // fallback
  }

  function showShare(won){
    const today = new Date();
    const dateStr = today.toISOString().split('T')[0].replace(/-/g, '-');
    
    $('#popTitle').textContent = getCustomTitle(won, strikes);
    $('#shareGrid').textContent = createEmojiGrid();
    $('#shareGrid').classList.add('emoji'); // Add emoji class for compound emoji support
    
    // Add statistics
    const winRate = stats.totalGames > 0 ? Math.round((stats.totalWins / stats.totalGames) * 100) : 0;
    const distribution = getStrikeDistribution();
    const maxStrikes = Math.max(...distribution);
    
    let statsHtml = `
      <div style="margin-top:20px;padding-top:20px;border-top:1px solid #eee;">
        <h4 style="margin:0 0 10px 0;">Statistics</h4>
        <div style="display:grid;grid-template-columns:1fr 1fr;gap:15px;font-size:14px;">
          <div>Current Win Streak: <strong>${stats.currentStreak}</strong></div>
          <div>Current Attempt Streak: <strong>${stats.currentAttemptStreak}</strong></div>
          <div>Longest Win Streak: <strong>${stats.longestStreak}</strong></div>
          <div>Longest Attempt Streak: <strong>${stats.longestAttemptStreak}</strong></div>
          <div>Win Rate: <strong>${winRate}%</strong></div>
          <div>Total Games: <strong>${stats.totalGames}</strong></div>
        </div>
        <div style="margin-top:15px;">
          <div style="font-size:12px;margin-bottom:5px;">Strikes Distribution:</div>
          <div style="display:flex;gap:2px;height:20px;align-items:end;">
    `;
    
    for (let i = 0; i < 4; i++) {
      const height = maxStrikes > 0 ? (distribution[i] / maxStrikes) * 100 : 0;
      const color = ['#4caf50', '#ffb300', '#ff9800', '#e53935'][i];
      statsHtml += `
        <div style="flex:1;background:${color};height:${height}%;min-height:2px;border-radius:1px;" title="${i} strikes: ${distribution[i]} games"></div>
      `;
    }
    
    statsHtml += `
          </div>
          <div style="display:flex;gap:2px;font-size:10px;margin-top:2px;">
            <div style="flex:1;text-align:center;">0</div>
            <div style="flex:1;text-align:center;">1</div>
            <div style="flex:1;text-align:center;">2</div>
            <div style="flex:1;text-align:center;">3</div>
          </div>
        </div>
      </div>
    `;
    
    $('#unsolved').innerHTML = statsHtml;
    $('#sharePop').classList.add('show');
  }
  $('#copy').onclick=()=>{ navigator.clipboard.writeText($('#shareGrid').textContent);
                           $('#copy').textContent='Copied!'; };
  $('#minShare').onclick=()=>{ $('#sharePop').classList.remove('show');
                               $('#shareBtn').style.display='block'; };
  $('#shareBtn').onclick=()=>{ $('#sharePop').classList.add('show'); };

  $('#helpIcon').onclick=()=>$('#helpPop').classList.add('show');
  $('#minHelp').onclick=$('#helpOK').onclick=()=>$('#helpPop').classList.remove('show');
  
  // GDPR popup handlers
  $('#acceptCookies').onclick=()=>{
    cookiesAccepted = true;
    setCookie('connecdoku_consent', true);
    $('#gdprPop').classList.remove('show');
  };
  $('#declineCookies').onclick=()=>{
    cookiesAccepted = false;
    setCookie('connecdoku_consent', false);
    $('#gdprPop').classList.remove('show');
  };
  
  // Unsolvable puzzle popup handlers
  $('#resetPuzzle').onclick=()=>{
    // Delete the current puzzle state cookie
    setCookie('connecdoku_state', null, -1);
    // Reload the page to start fresh
    window.location.reload();
  };
  $('#closeUnsolvable').onclick=()=>{
    $('#unsolvablePop').classList.remove('show');
  };
  
  // Hint button handler
  $('#hintBtn').onclick=()=>{
    const hintBtn = $('#hintBtn');
    
    if (hintBtn.textContent === 'hint') {
      // Show hint
      const categoryEmojis = getPuzzleCategoryEmojis();
      hintBtn.textContent = categoryEmojis;
      hintBtn.classList.add('emoji'); // Add emoji class for compound emoji support
    } else {
      // Hide hint
      hintBtn.textContent = 'hint';
      hintBtn.classList.remove('emoji'); // Remove emoji class
    }
  };
  
      // Restore visual state if we loaded saved state (after all functions are defined)
    if (savedState) {
      console.log('Restoring saved state:', savedState);
      console.log('solvedRows:', solvedRows);
      console.log('solvedCols:', solvedCols);
      
      // Restore solved headers
      solvedRows.forEach((level, r) => {
        console.log(`Restoring row ${r} with level ${level}`);
        const hdr = $(`.hdr[data-row="${r}"]`);
        if (hdr) {
          const words = G[r];
          const label = ans[hash(words)];
          if (label) {
            hdr.replaceWith(makeSolvedLabel(label, level));
          }
        }
      });
      
      solvedCols.forEach((level, c) => {
        console.log(`Restoring col ${c} with level ${level}`);
        const hdr = $(`.hdr[data-col="${c}"]`);
        if (hdr) {
          const colWords = [G[0][c], G[1][c], G[2][c], G[3][c]];
          const label = ans[hash(colWords)];
          if (label) {
            hdr.replaceWith(makeSolvedLabel(label, level));
          }
        }
      });
      
      // Freeze solved tiles with proper color priority
      for (let r = 0; r < 4; r++) {
        for (let c = 0; c < 4; c++) {
          const rowLevel = solvedRows.get(r);
          const colLevel = solvedCols.get(c);
          
          // Determine the best (lowest) strike level for this tile
          let bestLevel = null;
          if (rowLevel !== undefined && colLevel !== undefined) {
            bestLevel = Math.min(rowLevel, colLevel);
          } else if (rowLevel !== undefined) {
            bestLevel = rowLevel;
          } else if (colLevel !== undefined) {
            bestLevel = colLevel;
          }
          
          if (bestLevel !== null) {
            lockColour(r, c, bestLevel);
            freezeTile(r, c);
          }
        }
      }
      
      freezeIntersections();
      
      // If puzzle is already completed (either solved or failed), show share popup
      if (finished || (solvedRows.size === 4 && solvedCols.size === 4)) {
        // If finished due to 3 strikes, we need to show the correct category labels
        if (finished && strikes >= 3) {
          relabelAllHeaders();
        }
        
        setTimeout(() => {
          // Determine if it was a win or loss
          const won = solvedRows.size === 4 && solvedCols.size === 4;
          showShare(won);
          $('#shareBtn').style.display = 'block';
        }, 500);
      } else if (strikes >= 3) {
        // Handle case where game was finished with 3 strikes but finished flag wasn't set
        finished = true;
        
        // Rearrange words into proper solved positions (like after 3rd strike)
        const animTime = solveCompletely();
        
        // After swaps finish, show missing headers & freeze board
        setTimeout(() => {
          relabelAllHeaders();
          showShare(false); // false = lost
          $('#shareBtn').style.display = 'block';
        }, 1000 + animTime); // 1 s pause + animation
      }
    }
}
</script>
</body>
</html>

