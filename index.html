<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>Connecdoku</title>
<link rel="icon" href="favicon.ico">
<meta name="viewport" content="width=device-width,initial-scale=1">
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Fredoka+One&display=swap" rel="stylesheet">
<style>
/* --- styles unchanged from earlier versions --- */
:root{--tile:#f6f7f8;--tile-b:#d4d5d6;--s0:#b6e7b2;--s1:#ffe680;--s2:#ffb06a;
       --txt:#222;--btn1:#4caf50;--btn2:#ffb300;--btn3:#e53935}
body{font-family:system-ui,-apple-system,Segoe UI,Helvetica,Arial,sans-serif;
     margin:0;background:#fafafa;color:var(--txt)}
#shell{max-width:850px;margin:60px auto 40px;padding:0 12px;position:relative}
#logo{font-family:'Fredoka One',cursive;font-size:48px;margin:10px 0 28px;
      text-align:center;letter-spacing:1px;color:#222}
.grid{display:grid;grid-template-columns:repeat(5,1fr);gap:10px}
.tile,.hdr{border:2px solid var(--tile-b);border-radius:12px;box-sizing:border-box}
.tile{background:var(--tile);padding:6px 8px;display:flex;align-items:center;
      justify-content:center;min-height:90px;text-align:center;cursor:pointer;
      user-select:none;transition:background-color .3s ease}
.hdr{min-height:34px;display:flex;align-items:center;justify-content:center}
.hdr button{all:unset;cursor:pointer;color:var(--txt)}
.hdr.solved{font-weight:600;border:none}
.hdr.solved.pop{animation:pop .3s ease-out}
.rowCredit{margin-top:22px;font-size:13px;text-align:center;color:#777}
#helpIcon{position:absolute;top:-38px;right:16px;font-size:24px;cursor:pointer}
.strike{margin:16px 0;text-align:center;font-size:18px}
.lock0{background:var(--s0)}.lock1{background:var(--s1)}.lock2{background:var(--s2)}
.frozen{cursor:default}.selected{outline:3px solid #2196f3}
.used1{background:var(--btn2)}.used2{background:var(--btn3)}
.disabled{opacity:.5;cursor:default}.disabled button{display:none}
@keyframes pop{0%{transform:scale(.9)}70%{transform:scale(1.05)}100%{transform:scale(1)}}
@keyframes shake{0%,100%{transform:translateX(0)}20%,60%{transform:translateX(-8px)}
                 40%,80%{transform:translateX(8px)}}
.hdr.solved.pop{animation:pop 1s cubic-bezier(.34,1.56,.64,1)}
.shake{animation:shake 1.2s cubic-bezier(.36,0,.66,-.56)}
.modalBg{position:fixed;inset:0;background:rgba(0,0,0,.55);display:none;
         align-items:center;justify-content:center;z-index:20}
.modalBg.show{display:flex}
.modalCard{background:#fff;border-radius:10px;padding:26px 30px;max-width:360px}
.modalCard h3{margin-top:0}
.modalCard button.min{position:absolute;top:8px;right:10px;border:none;background:0;font-size:22px;cursor:pointer}
.modalCard button.action{margin-top:18px;padding:8px 14px;border:none;border-radius:6px;background:#4caf50;color:#fff;cursor:pointer}
#shareBtn{position:fixed;bottom:22px;right:22px;background:#4caf50;color:#fff;
          padding:10px 14px;border-radius:50px;display:none;cursor:pointer;
          box-shadow:0 2px 6px rgba(0,0,0,.25);z-index:15}
pre{white-space:pre-wrap;margin:12px 0;font-size:20px}
</style>
</head>
<body>
<div id="shell">
  <div id="helpIcon">â“</div><h1 id="logo">Connecdoku</h1>
  <div class="strike" id="strikeTxt"></div>
  <div id="board" class="grid"></div>
  <p class="rowCredit">Connecdoku was created by <a href="https://x.com/GarrettPetersen" target="_blank">@GarrettPetersen</a></p>
</div>

<!-- share popup -->
<div id="sharePop" class="modalBg">
  <div class="modalCard">
    <button class="min" id="minShare">Ã—</button>
    <h3 id="popTitle"></h3><pre id="shareGrid"></pre>
    <div id="unsolved"></div>
    <button class="action" id="copy">Copy to clipboard</button>
  </div>
</div>

<!-- help popup -->
<div id="helpPop" class="modalBg">
  <div class="modalCard">
    <button class="min" id="minHelp">Ã—</button>
    <h3>How to Play</h3>
    <p>Swap words by selecting two tiles.<br>
       When you think an entire <strong>row</strong> or <strong>column</strong> matches a hidden category, hit its âœ“ button.<br>
       â€¢ Correct lines lock (colour depends on your strike count).<br>
       â€¢ Wrong checks give a strike â€” after <strong>three</strong> you lose.<br>
       Solve every row <em>and</em> column to win!
    </p>
    <button class="action" id="helpOK">Got it!</button>
  </div>
</div>

<div id="shareBtn">Share</div>

<script>
/* ---------- tiny helpers ---------- */
const $=q=>document.querySelector(q);
const $$=q=>document.querySelectorAll(q);
const start=new Date('2025-07-21');
const todayIdx=()=>Math.floor((Date.now()-start)/864e5);
const clr=['lock0','lock1','lock2'], emj=['ğŸŸ©','ğŸŸ¨','ğŸŸ§'];

/* ---------- load puzzle ---------- */
fetch('daily_puzzles/puzzles.json')
  .then(r=>r.json())
  .then(all=>init(all[todayIdx()%all.length]));

function init(puz){

  const wordToColCat = {};          // use column labels
  const wordToRowCat = {};          // use row labels

  for (let r = 0; r < 4; r++) {
    for (let c = 0; c < 4; c++) {
      const w = puz.words[r][c];
      wordToRowCat[w] = puz.rows[r];    // category of its *row*
      wordToColCat[w] = puz.cols[c];    // category of its *column*
    }
  }

  /* answer lookup */
  const hash=a=>[...a].sort().join('|');
  const ans={};
  puz.rows.forEach((l,i)=>ans[hash(puz.words[i])]=l);
  for(let c=0;c<4;c++) ans[hash(puz.words.map(r=>r[c]))]=puz.cols[c];

  const rowIdx=Object.fromEntries(puz.rows.map((l,i)=>[l,i]));
  const colIdx=Object.fromEntries(puz.cols.map((l,i)=>[l,i]));

  /* board state */
  const flat=[...puz.words.flat()].map(v=>[Math.random(),v])
               .sort((a,b)=>a[0]-b[0]).map(v=>v[1]);
  const G=[[],[],[],[]]; let k=0;
  for(let r=0;r<4;r++)for(let c=0;c<4;c++)G[r][c]=flat[k++];

  /* dynamic canonical maps (created on first solve) */
  let colPos=null; // word â†’ target column   (defined when first row category solved)
  let rowPos=null; // word â†’ target row      (defined when first column category solved)

  /* game vars */
  let strikes=0, finished=false, sel=null;
  const solvedRows=new Map(), solvedCols=new Map(); // idx â†’ strike tier

  renderBoard(); updateStrike();

  /* ------------------------------------------------------------
    relabelAllHeaders()  â€“  hash-based, orientation-agnostic
    â€¢ Works after solveCompletely() finishes (every line is a set)
    â€¢ Reads the category from the *whole 4-word line*
    â€¢ Leaves solved headers untouched; greys unsolved ones
  ---------------------------------------------------------------- */
  function relabelAllHeaders() {
    const hash = a => [...a].sort().join('|');

    /* â”€â”€ rows â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
    for (let r = 0; r < 4; r++) {
      if (solvedRows.has(r)) continue;

      const hdr = document.querySelector(`.hdr[data-row="${r}"]`);
      if (!hdr) continue;

      const label = ans[hash(G[r])];
      if (label) {
        hdr.textContent = label;
      } else {
        hdr.textContent = 'â“';
        console.warn(
          `Row ${r}: [${G[r].join(', ')}] â†’ these four words don't make a category`
        );
      }
      hdr.classList.add('disabled');
      hdr.style.color = '#666';
    }

    /* â”€â”€ columns â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
    for (let c = 0; c < 4; c++) {
      if (solvedCols.has(c)) continue;

      const hdr = document.querySelector(`.hdr[data-col="${c}"]`);
      if (!hdr) continue;

      const colWords = [G[0][c], G[1][c], G[2][c], G[3][c]];
      const label = ans[hash(colWords)];
      if (label) {
        hdr.textContent = label;
      } else {
        hdr.textContent = 'â“';
        console.warn(
          `Col ${c}: [${colWords.join(', ')}] â†’ these four words don't make a category`
        );
      }
      hdr.classList.add('disabled');
      hdr.style.color = '#666';
    }
  }

  /* ---------- DOM ---------- */
  function renderBoard(){
    const bd=$('#board'); bd.innerHTML='';
    for(let c=0;c<4;c++) bd.appendChild(makeHdr('col',c));
    bd.appendChild(document.createElement('div'));
    for(let r=0;r<4;r++){
      for(let c=0;c<4;c++) bd.appendChild(makeTile(r,c));
      bd.appendChild(makeHdr('row',r));
    }
  }
  function makeTile(r,c){
    const d=document.createElement('div');
    d.className='tile'; d.textContent=G[r][c]; d.dataset.rc=`${r},${c}`;
    return d;
  }
  function makeHdr(kind,idx){
    const d=document.createElement('div');
    d.className='hdr clickHdr'; d.dataset[kind]=idx;
    d.innerHTML='<button>âœ“</button>'; return d;
  }
  const tile=(r,c)=>$(`.tile[data-rc="${r},${c}"]`);
  const lockColour=(r,c,lvl)=>{
    const t=tile(r,c);
    // Only apply color if it's better (lower strike count) than existing
    const hasBetter=t.classList.contains('lock0')||(lvl>0&&t.classList.contains('lock1'))||(lvl>1&&t.classList.contains('lock2'));
    if(!hasBetter) t.classList.add(clr[lvl]);
  };
  
  /* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    freezeTile(r,c)  â€“ v2
    â€¢ Marks the tile as frozen
    â€¢ Guarantees a frozen tile can never remain selected
    â€¢ Clears the global `sel` pointer when necessary
  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
  const freezeTile = (r, c) => {
    const t = tile(r, c);
    if (!t) return;

    t.classList.add('frozen');

    if (t.classList.contains('selected')) {
      t.classList.remove('selected');
      if (sel === t) sel = null;
    }
  };

  // return a string like "StarWars|Pokemon|Fruits|Cities"
  function categorySignature(words) {
    return words     // words = 4-item array
      .map(w => ans[[...w].sort().join('|')])  // look up its category
      .join('|');
  }

  /* ---------- click handling ---------- */
  $('#board').addEventListener('click',e=>{
    if(finished) return;
    const t=e.target.closest('.tile');
    const h=e.target.closest('.clickHdr');
    if(t && !t.classList.contains('frozen')) handleTileClick(t);
    if(h){
      const r=h.dataset.row!==undefined?+h.dataset.row:null;
      const c=h.dataset.col!==undefined?+h.dataset.col:null;
      if(r!==null) checkLine('row',r,h);
      if(c!==null) checkLine('col',c,h);
    }
  });

  function handleTileClick(td){
    if(sel===td){ td.classList.remove('selected'); sel=null; return; }
    if(!sel){ td.classList.add('selected'); sel=td; return; }

    const [r1,c1]=sel.dataset.rc.split(',').map(Number);
    const [r2,c2]=td.dataset.rc.split(',').map(Number);
    if(solvedRows.has(r1)||solvedRows.has(r2)||solvedCols.has(c1)||solvedCols.has(c2)) return;
    swapCells(r1,c1,r2,c2,true);
    sel.classList.remove('selected'); sel=null;

    integrityCheck();
  }

  /* ---------- solving logic ---------- */
  function checkLine(kind,idx,hdr,auto=false){
    if(hdr.classList.contains('solved')) return;

    if(!auto && (
      (kind==='row'&&solvedRows.size>=3&&solvedCols.size<4)||
      (kind==='col'&&solvedCols.size>=3&&solvedRows.size<4))) return;

    const words=kind==='row'?G[idx]:G.map(r=>r[idx]);
    const label=ans[hash(words)];
    if(!label) return badAttempt(hdr);

    /* ---- create canonical maps on first solve ---- */
    if(colPos===null && rowIdx[label]!==undefined){        // first ROW category solved
      colPos={};                                           // build from this lineâ€™s order
      if(kind==='row') for(let c=0;c<4;c++) colPos[G[idx][c]]=c;
      else              for(let r=0;r<4;r++) colPos[G[r][idx]]=r; // row category solved vertically (transpose)
    }
    if(rowPos===null && colIdx[label]!==undefined){        // first COLUMN category solved
      rowPos={};
      if(kind==='col') for(let r=0;r<4;r++) rowPos[G[r][idx]]=r;
      else              for(let c=0;c<4;c++) rowPos[G[idx][c]]=c; // column category solved horizontally
    }

    /* ---- update UI ---- */
    const lvl=strikes;
    const solved=kind==='row'?solvedRows:solvedCols;
    hdr.replaceWith(makeSolvedLabel(label,lvl));
    solved.set(idx,lvl);
    colourAndFreeze(kind,idx,lvl);

    if(kind==='row' && colPos) alignRow(idx);
    if(kind==='col' && rowPos) alignCol(idx);

    freezeIntersections();
    if((kind==='row'&&solvedRows.size===3)||(kind==='col'&&solvedCols.size===3))
      disableSameHeaders(kind);

    if(!finished) autoEndIfObvious();
    if(solvedRows.size===4&&solvedCols.size===4) finish(true);

    integrityCheck();
  }

  function makeSolvedLabel(txt,lvl){
    const d=document.createElement('div');
    d.className=`hdr solved ${clr[lvl]} pop`; d.textContent=txt; return d;
  }
  const colourAndFreeze=(k,i,l)=>{
    if(k==='row') for(let c=0;c<4;c++){ lockColour(i,c,l); freezeTile(i,c); }
    else          for(let r=0;r<4;r++){ lockColour(r,i,l); freezeTile(r,i); }
  };

  /* ---------------------------------------------------------------
    alignRow(r)                 â€“  same-orientation anchoring
    ------------------------------------------------------------- */
  function alignRow(r) {
    /* nothing to align against if this is the very first solved row */
    if (solvedRows.size === 0) return;

    /* use the first frozen row as the template for column order */
    const refRow = [...solvedRows.keys()][0];

    /* category  â†’  column index, as dictated by that template row */
    const catToCol = {};
    for (let c = 0; c < 4; c++) {
      const cat = wordToColCat[G[refRow][c]];   // column-category of that word
      catToCol[cat] = c;
    }

    /* walk left-to-right twice, swapping into the right slots
      (second pass mops up knock-on effects)                    */
    for (let pass = 0; pass < 2; pass++) {
      for (let c = 0; c < 4; c++) {
        if (solvedCols.has(c)) continue;                       // frozen column
        const cat  = wordToColCat[G[r][c]];
        const want = catToCol[cat];
        if (want !== undefined && want !== c && !solvedCols.has(want)) {
          swapCells(r, c, r, want, true);                      // visual swap
        }
      }
    }
  }



  /* ---------------------------------------------------------------
    alignCol(c)                 â€“  same-orientation anchoring
    ------------------------------------------------------------- */
  function alignCol(c) {
    /* nothing to align against if this is the very first solved col */
    if (solvedCols.size === 0) return;

    /* use the first frozen column as the template for row order */
    const refCol = [...solvedCols.keys()][0];

    /* category  â†’  row index, as dictated by that template column */
    const catToRow = {};
    for (let r = 0; r < 4; r++) {
      const cat = wordToRowCat[G[r][refCol]];   // row-category of that word
      catToRow[cat] = r;
    }

    /* walk top-to-bottom twice, swapping into the right slots
      (second pass mops up knock-on effects)                   */
    for (let pass = 0; pass < 2; pass++) {
      for (let r = 0; r < 4; r++) {
        if (solvedRows.has(r)) continue;                       // frozen row
        const cat  = wordToRowCat[G[r][c]];
        const want = catToRow[cat];
        if (want !== undefined && want !== r && !solvedRows.has(want)) {
          swapCells(r, c, want, c, true);                      // visual swap
        }
      }
    }
  }


  function freezeIntersections(){
    for(const r of solvedRows.keys())
      for(const c of solvedCols.keys()) freezeTile(r,c);
  }

  function disableSameHeaders(kind){
    const solvedMap=kind==='row'?solvedRows:solvedCols;
    for(let i=0;i<4;i++){
      if(solvedMap.has(i)) continue;
      const hdr=$(`.hdr[data-${kind}="${i}"]`);
      if(hdr){ hdr.classList.add('disabled'); hdr.innerHTML=''; }
    }
    checkAutoSolve();
  }

  function checkAutoSolve(){
    if(solvedRows.size+solvedCols.size!==6) return;
    const r=[0,1,2,3].find(i=>!solvedRows.has(i));
    const c=[0,1,2,3].find(i=>!solvedCols.has(i));
    
    // Force rearrange to canonical order
    const canonicalGrid = puz.words;
    
    // Rearrange the entire grid to canonical order
    for(let row=0;row<4;row++){
      for(let col=0;col<4;col++){
        if(G[row][col]!==canonicalGrid[row][col]){
          // Find where the correct word is
          for(let r2=0;r2<4;r2++){
            for(let c2=0;c2<4;c2++){
              if(G[r2][c2]===canonicalGrid[row][col]){
                swapCells(row,col,r2,c2,true);
                break;
              }
            }
          }
        }
      }
    }
    
    setTimeout(()=>{
      const rh=$(`.hdr[data-row="${r}"]`);
      const ch=$(`.hdr[data-col="${c}"]`);
      if(rh) checkLine('row',r,rh,true);
      if(ch) checkLine('col',c,ch,true);
    },500);
  }

  /* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ strikes / misc â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
  function badAttempt(hdr) {

    /* mark header, add strike, shake */
    strikes++;
    hdr.classList.add(strikes === 1 ? 'used1' : 'used2');
    shake();
    updateStrike();

    /* third strike â‡’ auto-solve, reveal labels, end game */
    if (strikes === 3) {

      // put every word in its true final position
      const animTime = solveCompletely();   // may be 0 ms if nothing moved

      // after swaps finish, show missing headers & freeze board
      setTimeout(() => {
        relabelAllHeaders();
        finish(false);
      }, 1000 + animTime);                  // 1 s pause + animation
    }
  }


  function updateStrike(){ $('#strikeTxt').textContent=`Strikes ${strikes}/3`; }
  const shake=()=>{ $('#shell').classList.add('shake');
                    setTimeout(()=>$('#shell').classList.remove('shake'),1200); };

  /* -------------------------------------------------
    swapCells(r1, c1, r2, c2, animate = false, animOnly = false)
    ----------------------------------------------------------- */
  function swapCells(r1, c1, r2, c2, animate = false, animOnly = false) {
    if (r1 === r2 && c1 === c2) return;

    const t1 = tile(r1, c1);
    const t2 = tile(r2, c2);
    if (!t1 || !t2) return;

    /* â”€â”€ visual animation â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
    if (animate) {
      const a = t1.getBoundingClientRect();
      const b = t2.getBoundingClientRect();
      const dx = b.left - a.left;
      const dy = b.top - a.top;
      const opt = { duration: 500, easing: 'cubic-bezier(.4,0,.2,1)' };

      t1.animate([{ transform: `translate(${dx}px,${dy}px)` }, { transform: 'none' }], opt);
      t2.animate([{ transform: `translate(${-dx}px,${-dy}px)` }, { transform: 'none' }], opt);

      /* update the text **after** the slide completes so it looks natural */
      setTimeout(() => {
        t1.textContent = G[r1][c1];
        t2.textContent = G[r2][c2];
      }, opt.duration);
    }

    /* â”€â”€ logical swap (unless weâ€™re only animating) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
    if (!animOnly) {
      [G[r1][c1], G[r2][c2]] = [G[r2][c2], G[r1][c1]];
      [t1.textContent, t2.textContent] = [t2.textContent, t1.textContent];
      integrityCheck();
    }
  }

  function autoEndIfObvious(){
    if(solvedRows.size===3&&solvedCols.size<4){
      const r=[0,1,2,3].find(i=>!solvedRows.has(i));
      checkLine('row',r,$(`.hdr[data-row="${r}"]`));
    }else if(solvedCols.size===3&&solvedRows.size<4){
      const c=[0,1,2,3].find(i=>!solvedCols.has(i));
      checkLine('col',c,$(`.hdr[data-col="${c}"]`));
    }
  }

  function finish(won) {
    finished = true;

    // just freeze everything; leave the current board text untouched
    for (let r = 0; r < 4; r++)
      for (let c = 0; c < 4; c++)
        freezeTile(r, c);

    setTimeout(() => showShare(won), 600);

    integrityCheck();
  }

  /* ------------------------------------------------------------
    getOrientation()
    â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    Inspect the *first* solved line (row or column). If its
    category lives in puz.rows => normal orientation,
    otherwise we treat the puzzle as transposed.
  ---------------------------------------------------------------- */
  function getOrientation() {
    if (solvedRows.size) {
      const r   = [...solvedRows.keys()][0];
      const cat = ans[hash(G[r])];                 // category of that row
      return puz.rows.includes(cat) ? 'normal' : 'transposed';
    }
    if (solvedCols.size) {
      const c   = [...solvedCols.keys()][0];
      const cat = ans[hash(G.map(r => r[c]))];     // category of that col
      return puz.cols.includes(cat) ? 'normal' : 'transposed';
    }
    return 'normal';                               // fallback until something is solved
  }

  /* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ integrity guard v3 â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
  const solvedPositions = new Map();   // word â†’ { r, c }

  function integrityCheck() {
    /* 1-a. solved words may never move */
    for (let r = 0; r < 4; r++) {
      for (let c = 0; c < 4; c++) {
        if (!solvedRows.has(r) && !solvedCols.has(c)) continue;
        const w   = G[r][c];
        const pos = solvedPositions.get(w);
        if (!pos) solvedPositions.set(w, { r, c });
        else if (pos.r !== r || pos.c !== c) {
          throw new Error(`Solved word "${w}" moved from [${pos.r},${pos.c}] to [${r},${c}]`);
        }
      }
    }

    /* 1-b. every fully-solved line must hash to a known category */
    const hash = a => [...a].sort().join('|');
    for (const r of solvedRows.keys()) {
      if (!ans[hash(G[r])]) throw new Error(`Row ${r} claims solved but is not a valid set`);
    }
    for (const c of solvedCols.keys()) {
      const col = [G[0][c], G[1][c], G[2][c], G[3][c]];
      if (!ans[hash(col)]) throw new Error(`Column ${c} claims solved but is not a valid set`);
    }
  }

  /* ------------------------------------------------------------
    solveCompletely()  â€“  â€œreconstruct-then-swapâ€ solver  v5
  ---------------------------------------------------------------- */
  function solveCompletely() {

    const hash = a => [...a].sort().join('|');

    /* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      0.  Nothing solved? â‡’ return to canonical grid
    â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
    if (!solvedRows.size && !solvedCols.size) {
      const moves = [];
      for (let r = 0; r < 4; r++)
        for (let c = 0; c < 4; c++) {
          const want = puz.words[r][c];
          if (G[r][c] === want) continue;

          outer: for (let r2 = 0; r2 < 4; r2++)
            for (let c2 = 0; c2 < 4; c2++)
              if (G[r2][c2] === want) {
                moves.push([r, c, r2, c2]);
                [G[r][c], G[r2][c2]] = [G[r2][c2], G[r][c]];
                break outer;
              }
        }
      moves.forEach((m, i) => setTimeout(() => swapCells(...m, true, true), i * 100));
      return moves.length * 100;
    }

    /* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      1.  Detect orientation  (normal / transposed)
    â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
    const firstCat = solvedRows.size
        ? ans[hash(G[[...solvedRows.keys()][0]])]
        : ans[hash(G.map(r => r[[...solvedCols.keys()][0]]))];

    const transposed = puz.cols.includes(firstCat);

    const ROW_LABELS = transposed ? puz.cols : puz.rows;
    const COL_LABELS = transposed ? puz.rows : puz.cols;

    const rowCatOf   = w => transposed ? wordToColCat[w] : wordToRowCat[w];
    const colCatOf   = w => transposed ? wordToRowCat[w] : wordToColCat[w];
    const rowIdxOf   = cat => (transposed ? colIdx : rowIdx)[cat];
    const colIdxOf   = cat => (transposed ? rowIdx : colIdx)[cat];

    /* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      2.  Row / column category â†’ index maps
    â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
    const rowCatToIdx = {};      // category â†’ row#
    const colCatToIdx = {};      // category â†’ col#

    solvedRows.forEach((_, r) => {
      const cat = ans[hash(G[r])];                // look at the whole 4-word row
      if (cat) rowCatToIdx[cat] = r;
    });

    solvedCols.forEach((_, c) => {
      const colWords = [G[0][c], G[1][c], G[2][c], G[3][c]];
      const cat = ans[hash(colWords)];            // whole 4-word column
      if (cat) colCatToIdx[cat] = c;
    });

    /* assign remaining categories to free indices (canonical order) */
    const freeRows = [0,1,2,3].filter(i => !Object.values(rowCatToIdx).includes(i));
    const freeCols = [0,1,2,3].filter(i => !Object.values(colCatToIdx).includes(i));

    ROW_LABELS.forEach(cat => {
      if (rowCatToIdx[cat] === undefined) rowCatToIdx[cat] = freeRows.shift();
    });
    COL_LABELS.forEach(cat => {
      if (colCatToIdx[cat] === undefined) colCatToIdx[cat] = freeCols.shift();
    });

    /* idx â†’ category arrays (no nulls) */
    const idxToRowCat = Array(4).fill('').map((_,i)=>
          Object.keys(rowCatToIdx).find(k=>rowCatToIdx[k]===i));
    const idxToColCat = Array(4).fill('').map((_,i)=>
          Object.keys(colCatToIdx).find(k=>colCatToIdx[k]===i));

    /* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      3.  Build the target 4Ã—4 grid
    â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
    const target = Array.from({length:4},()=>Array(4));

    for (let r = 0; r < 4; r++) {
      const rowCat = idxToRowCat[r];
      for (let c = 0; c < 4; c++) {
        const colCat = idxToColCat[c];

        const canonRow = transposed ? colIdx[rowCat] : rowIdx[rowCat];
        const canonCol = transposed ? rowIdx[colCat] : colIdx[colCat];

        target[r][c] = puz.words[canonRow][canonCol];
      }
    }

    /* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      4.  Swap current grid â†’ target grid (skip anchors)
    â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
    const locate = new Map();                // word â†’ [r,c]
    for (let r=0;r<4;r++)for(let c=0;c<4;c++) locate.set(G[r][c],[r,c]);

    const moves = [];

    for (let r = 0; r < 4; r++) {
      for (let c = 0; c < 4; c++) {

        if (solvedRows.has(r) || solvedCols.has(c)) continue;   // frozen

        const want = target[r][c];
        if (G[r][c] === want) continue;

        const [r2, c2] = locate.get(want);
        if (solvedRows.has(r2) || solvedCols.has(c2)) continue; // would move anchor

        moves.push([r, c, r2, c2]);

        /* update bookkeeping & virtual grid */
        locate.set(G[r][c], [r2, c2]);
        locate.set(want,    [r , c ]);
        [G[r][c], G[r2][c2]] = [G[r2][c2], G[r][c]];
      }
    }

    /* animate the swaps in a 100 ms cascade */
    moves.forEach((m,i)=>setTimeout(()=>swapCells(...m,true), i*100));
    return moves.length * 100;          // total animation time
  }

  /* ---------- share popup ---------- */
  function emojiFor(td){ return td.classList.contains('lock0')?emj[0]:
                               td.classList.contains('lock1')?emj[1]:
                               td.classList.contains('lock2')?emj[2]:'â¬›'; }
  function gridEmoji(){
    const rows=[[],[],[],[]];
    $$('.tile').forEach(t=>{
      const [r,c]=t.dataset.rc.split(',').map(Number);
      rows[r][c]=emojiFor(t);
    });
    return rows.map(r=>r.join('')).join('\n');
  }
  function showShare(won){
    $('#popTitle').textContent=won?'Puzzle solved!':'Out of guesses';
    $('#shareGrid').textContent=gridEmoji();
    if(won) $('#unsolved').innerHTML='';
    else{
      // Get current grid state and find what categories each line represents
      const currentRows = G.map(row => hash(row));
      const currentCols = Array(4).fill().map((_,i) => hash(G.map(r => r[i])));
      
      // Find which categories are actually unsolved
      const unsR = puz.rows.filter((label, i) => !solvedRows.has(i) && ans[currentRows[i]] !== label);
      const unsC = puz.cols.filter((label, i) => !solvedCols.has(i) && ans[currentCols[i]] !== label);
      
      $('#unsolved').innerHTML=
        `<p><strong>Unsolved rows:</strong><br>${unsR.join('<br>')}</p>
         <p><strong>Unsolved cols:</strong><br>${unsC.join('<br>')}</p>`;
    }
    $('#sharePop').classList.add('show');
  }
  $('#copy').onclick=()=>{ navigator.clipboard.writeText($('#shareGrid').textContent);
                           $('#copy').textContent='Copied!'; };
  $('#minShare').onclick=()=>{ $('#sharePop').classList.remove('show');
                               $('#shareBtn').style.display='block'; };
  $('#shareBtn').onclick=()=>{ $('#shareBtn').style.display='none';
                               $('#sharePop').classList.add('show'); };

  $('#helpIcon').onclick=()=>$('#helpPop').classList.add('show');
  $('#minHelp').onclick=$('#helpOK').onclick=()=>$('#helpPop').classList.remove('show');
}
</script>
</body>
</html>
