<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>Connecdoku</title>
<link rel="icon" href="favicon.ico">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="description" content="A daily word puzzle game where you fill a 4x4 grid by finding words that belong to both row and column categories. Each word must be unique to its intersection!">

<!-- Open Graph / Facebook -->
<meta property="og:type" content="website">
<meta property="og:url" content="https://connecdoku.com/">
<meta property="og:title" content="Connecdoku - Daily Word Connection Puzzle">
<meta property="og:description" content="A daily word puzzle game where you fill a 4x4 grid by finding words that belong to both row and column categories. Each word must be unique to its intersection!">
<meta property="og:image" content="https://connecdoku.com/social-preview.png">
<meta property="og:image:width" content="1200">
<meta property="og:image:height" content="630">

<!-- Twitter -->
<meta property="twitter:card" content="summary_large_image">
<meta property="twitter:url" content="https://connecdoku.com/">
<meta property="twitter:title" content="Connecdoku - Daily Word Connection Puzzle">
<meta property="twitter:description" content="A daily word puzzle game where you fill a 4x4 grid by finding words that belong to both row and column categories. Each word must be unique to its intersection!">
<meta property="twitter:image" content="https://connecdoku.com/social-preview.png">

<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Fredoka+One&display=swap" rel="stylesheet">
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-1401790448375434"
     crossorigin="anonymous"></script>
<style>
/* --- styles unchanged from earlier versions --- */
:root{--tile:#f6f7f8;--tile-b:#d4d5d6;--s0:#b6e7b2;--s1:#ffe680;--s2:#ffb06a;
       --txt:#222;--btn1:#4caf50;--btn2:#ffb300;--btn3:#e53935}
body{font-family:system-ui,-apple-system,Segoe UI,Helvetica,Arial,sans-serif;
     margin:0;background:#fafafa;color:var(--txt)}
/* Add emoji font support for compound emojis */
.emoji{font-family:"Apple Color Emoji","Segoe UI Emoji","Noto Color Emoji","Android Emoji","EmojiSymbols","EmojiOne Mozilla","Twemoji Mozilla","Segoe UI Symbol",system-ui,-apple-system,Segoe UI,Helvetica,Arial,sans-serif}
#shell{max-width:850px;margin:60px auto 40px;padding:0 12px;position:relative}
@media (max-width: 768px) {
  #shell { margin: 20px auto 20px; padding: 0 8px; }
  #logo { font-size: 36px; margin: 10px 0 20px; }
}
#logo{font-family:'Fredoka One',cursive;font-size:48px;margin:10px 0 28px;
      text-align:center;letter-spacing:1px;color:#222}
.grid{display:grid;grid-template-columns:repeat(5,1fr);gap:10px}
@media (max-width: 768px) {
  .grid { gap: 4px; }
  .grid { grid-template-columns: 1fr 1fr 1fr 1fr 0.8fr; } /* Make row headers narrower */
}
.tile,.hdr{border:2px solid var(--tile-b);border-radius:12px;box-sizing:border-box}
.tile{background:var(--tile);padding:6px 8px;display:flex;align-items:center;
      justify-content:center;min-height:90px;text-align:center;cursor:pointer;
      user-select:none;transition:background-color .3s ease;
      word-wrap:break-word;overflow-wrap:break-word;hyphens:auto;
      white-space:normal;word-spacing:normal;line-height:1.2;
      lang:auto;
      font-size:clamp(11px, 4vw, 16px)}
@media (max-width: 768px) {
  .tile { min-height: 65px; padding: 3px 4px; font-size: 13px; line-height: 1.1; }
}
@media (max-width: 480px) {
  .tile { font-size: 11px; padding: 2px 3px; line-height: 1.0; }
}
@media (max-width: 360px) {
  .tile { font-size: 10px; padding: 1px 2px; line-height: 0.9; }
}
.hdr{min-height:34px;display:flex;align-items:center;justify-content:center;cursor:pointer;transition:filter .2s ease;text-align:center;white-space:normal;word-spacing:normal}
@media (max-width: 768px) {
  .hdr { min-height: 28px; font-size: 14px; text-align: center; white-space: normal; word-spacing: normal; }
  .hdr[data-row] { min-width: 50px; padding: 2px 4px; } /* Compact row headers for mobile */
}
.hdr.emoji{font-family:"Apple Color Emoji","Segoe UI Emoji","Noto Color Emoji","Android Emoji","EmojiSymbols","EmojiOne Mozilla","Twemoji Mozilla","Segoe UI Symbol",system-ui,-apple-system,Segoe UI,Helvetica,Arial,sans-serif}
.hdr:hover{filter:brightness(0.9)}
.hdr button{all:unset;cursor:pointer;color:var(--txt);font-size:16px;font-weight:bold;transition:all .2s ease}
.hdr.solved{font-weight:600;border:none;cursor:default}
.hdr.solved:hover{filter:none}
.hdr.solved.pop{animation:pop .3s ease-out}
.rowCredit{margin-top:22px;font-size:13px;text-align:center;color:#777}
#helpIcon{position:absolute;top:-38px;right:16px;font-size:24px;cursor:pointer}
@media (max-width: 768px) {
  #helpIcon { top: 8px; right: 8px; font-size: 20px; }
}
.strike{margin:16px 0;text-align:center;font-size:18px}
.lock0{background:var(--s0)}.lock1{background:var(--s1)}.lock2{background:var(--s2)}
.frozen{cursor:default}.selected{outline:3px solid #2196f3}
.used1{background:var(--btn2)}.used2{background:var(--btn3)}
.disabled{opacity:.5;cursor:default}.disabled button{display:none}

/* New styles for arrow buttons and confirmation flow */
.hdr.confirming{background:#e3f2fd;border-color:#2196f3}
.hdr.confirming button{color:#1976d2;font-weight:bold}
.tile.row-confirming{background:#e1f5fe !important;border-color:#03a9f4 !important}
.tile.col-confirming{background:#e1f5fe !important;border-color:#03a9f4 !important}
.confirm-btn{color:#1976d2 !important;font-weight:bold !important;font-size:14px !important}
@media (max-width: 768px) {
  .confirm-btn{font-size:11px !important}
}
.arrow-btn{font-size:18px !important;font-weight:bold !important;transition:all .2s ease !important}
.arrow-btn:hover{transform:scale(1.1) !important}

/* Disabled header message styles */
.disabled-message{
  position:absolute;
  background:#333;
  color:#fff;
  padding:8px 12px;
  border-radius:6px;
  font-size:14px;
  font-weight:500;
  z-index:100;
  pointer-events:none;
  opacity:0;
  transform:translateY(-10px);
  transition:opacity .2s ease,transform .2s ease;
  white-space:nowrap;
  box-shadow:0 4px 12px rgba(0,0,0,0.3);
}
.disabled-message.show{
  opacity:1;
  transform:translateY(0);
}
.disabled-message::after{
  content:'';
  position:absolute;
  bottom:-4px;
  left:50%;
  transform:translateX(-50%);
  border-left:4px solid transparent;
  border-right:4px solid transparent;
  border-top:4px solid #333;
}

@keyframes pop{0%{transform:scale(.9)}70%{transform:scale(1.05)}100%{transform:scale(1)}}
@keyframes shake{0%,100%{transform:translateX(0)}20%,60%{transform:translateX(-8px)}
                 40%,80%{transform:translateX(8px)}}
.hdr.solved.pop{animation:pop 1s cubic-bezier(.34,1.56,.64,1)}
.shake{animation:shake 1.2s cubic-bezier(.36,0,.66,-.56)}
.modalBg{position:fixed;inset:0;background:rgba(0,0,0,.55);display:none;
         align-items:center;justify-content:center;z-index:20;overflow-y:auto;padding:20px}
.modalBg.show{display:flex}
.modalCard{background:#fff;border-radius:10px;padding:26px 30px;max-width:360px;position:relative;max-height:90vh;overflow-y:auto}
.modalCard h3{margin-top:0}
.modalCard button.min{position:absolute;top:8px;right:10px;border:none;background:0;font-size:22px;cursor:pointer}
.modalCard button.action{margin-top:18px;padding:8px 14px;border:none;border-radius:6px;background:#4caf50;color:#fff;cursor:pointer}
@media (max-width: 768px) {
  .modalBg { padding: 10px; }
  .modalCard { max-width: calc(100vw - 20px); max-height: calc(100vh - 20px); padding: 20px 24px; }
  .modalCard button.min { top: 12px; right: 12px; font-size: 24px; }
  .modalCard button.action { margin-top: 20px; padding: 12px 18px; font-size: 16px; }
}
#shareBtn{position:fixed;bottom:22px;right:22px;background:#4caf50;color:#fff;
          padding:12px 18px;border-radius:50px;display:none;cursor:pointer;
          box-shadow:0 4px 12px rgba(0,0,0,.3);z-index:15;font-weight:bold;
          font-size:16px;min-width:80px;text-align:center}
@media (max-width: 768px) {
  #shareBtn { bottom: 20px; right: 20px; padding: 14px 20px; font-size: 16px; 
              min-width: 100px; box-shadow: 0 6px 16px rgba(0,0,0,.35); }
}
pre{white-space:pre-wrap;margin:12px 0;font-size:20px}
@media (max-width: 768px) {
  pre { font-size: 16px; margin: 8px 0; }
  
  /* Mobile optimization for sharing modal statistics */
  #sharePop .modalCard {
    max-width: calc(100vw - 20px);
    max-height: calc(100vh - 20px);
    padding: 20px 24px;
  }
  
  #sharePop .modalCard h3 {
    font-size: 18px;
    margin-bottom: 15px;
  }
  
  #sharePop .modalCard h4 {
    font-size: 16px;
    margin-bottom: 8px;
  }
  
  #sharePop .modalCard .stats-grid {
    grid-template-columns: 1fr !important;
    gap: 8px !important;
    font-size: 13px !important;
  }
  
  #sharePop .modalCard .stats-grid div {
    padding: 4px 0;
  }
  
  #sharePop .modalCard .strikes-chart {
    height: 16px !important;
    gap: 1px !important;
  }
  
  #sharePop .modalCard .strikes-chart + div {
    font-size: 9px !important;
  }
}
pre.emoji{font-family:"Apple Color Emoji","Segoe UI Emoji","Noto Color Emoji","Android Emoji","EmojiSymbols","EmojiOne Mozilla","Twemoji Mozilla","Segoe UI Symbol",system-ui,-apple-system,Segoe UI,Helvetica,Arial,sans-serif}
</style>
</head>
<body>
  <div id="shell">
    <div id="helpIcon">‚ùì</div><h1 id="logo">Connecdoku</h1>
    <div class="strike" id="strikeTxt"></div>
    <div id="board" class="grid"></div>
    <div id="hintContainer" style="text-align:center;margin:15px 0;display:none;">
      <button id="hintBtn" style="padding:10px 20px;border:none;border-radius:20px;background:#999;color:#fff;cursor:pointer;font-size:14px;font-weight:500;">hint</button>
    </div>
    <p class="rowCredit">Connecdoku was created by <a href="https://x.com/GarrettPetersen" target="_blank">@GarrettPetersen</a></p>
    
    <div style="margin-top: 30px; padding-top: 20px; border-top: 1px solid #ddd; text-align: center; font-size: 14px;">
      <a href="index.html" style="color: #4caf50; text-decoration: none; margin: 0 10px;">Play Game</a>
      <a href="archive.html" style="color: #4caf50; text-decoration: none; margin: 0 10px;">Puzzle Archive</a>
      <a href="contact.html" style="color: #4caf50; text-decoration: none; margin: 0 10px;">Contact</a>
      <a href="privacy.html" style="color: #4caf50; text-decoration: none; margin: 0 10px;">Privacy Policy</a>
    </div>
  </div>

<!-- share popup -->
<div id="sharePop" class="modalBg">
  <div class="modalCard">
    <button class="min" id="minShare">√ó</button>
    <h3 id="popTitle"></h3><pre id="shareGrid"></pre>
    <button class="action" id="copy">Copy to clipboard</button>
    <div id="unsolved"></div>
    <button class="action" id="returnToPuzzle" style="background:#666">Return to puzzle</button>
  </div>
</div>

<!-- GDPR popup -->
<div id="gdprPop" class="modalBg">
  <div class="modalCard">
    <h3>Cookie Consent</h3>
    <p>This website uses cookies to save your game progress and statistics. 
       This helps you continue where you left off and track your performance over time.</p>
    <p>We only use essential cookies for game functionality. No tracking or advertising cookies are used.</p>
    <div style="display:flex;gap:10px;margin-top:20px;">
      <button class="action" id="acceptCookies">Accept</button>
      <button class="action" style="background:#666" id="declineCookies">Decline</button>
    </div>
  </div>
</div>

<!-- help popup -->
<div id="helpPop" class="modalBg">
  <div class="modalCard">
    <button class="min" id="minHelp">√ó</button>
    <h3>How to Play</h3>
    <p><strong>Goal:</strong> Organize the 16 words into a 4√ó4 grid where each row and column forms a category.</p>
    
    <p><strong>How to play:</strong></p>
    <ul style="margin: 10px 0; padding-left: 20px;">
      <li><strong>Swap words:</strong> Click two tiles to swap their positions</li>
      <li><strong>Check categories:</strong> When you think a row or column matches a category, click its arrow button (‚Üê for rows, ‚Üì for columns)</li>
      <li><strong>Confirm guesses:</strong> The arrow changes to "confirm" and highlights the row/column. Click "confirm" to submit your guess</li>
      <li><strong>Correct guesses:</strong> Lock in place with a color (green ‚Üí yellow ‚Üí orange based on strikes)</li>
      <li><strong>Wrong guesses:</strong> Add a strike (‚ùå) ‚Äî 3 strikes and you lose!</li>
      <li><strong>Solving order:</strong> When you solve 3 rows, you must complete the puzzle by solving columns, and vice versa</li>
    </ul>
    
    <p><strong>Auto-alignment:</strong> When you solve multiple rows, they automatically rearrange to align with each other, revealing hints about the column categories. The same happens with columns!</p>
    
    <p><strong>Win condition:</strong> Solve all 4 rows AND all 4 columns to win!</p>
    
    <p style="margin-top: 15px; font-size: 14px; color: #666;">
      üí° <strong>Tip:</strong> Start by looking for obvious word groups, then use the arrow buttons to test your hunches!
    </p>
    <button class="action" id="helpOK">Got it!</button>
  </div>
</div>

<!-- unsolvable puzzle popup -->
<div id="unsolvablePop" class="modalBg">
  <div class="modalCard">
    <h3>‚ö†Ô∏è Puzzle Error</h3>
    <p>Your puzzle has become unsolvable. This is a bug in the game.</p>
    <p>Please tweet at <a href="https://x.com/GarrettPetersen" target="_blank">@GarrettPetersen</a> on X to report this issue.</p>
    <div style="display:flex;gap:10px;margin-top:20px;">
      <button class="action" id="resetPuzzle">Reset Puzzle</button>
      <button class="action" style="background:#666" id="closeUnsolvable">Close</button>
    </div>
  </div>
</div>

<div id="shareBtn">Share</div>

<script>
/* ---------- tiny helpers ---------- */
const $=q=>document.querySelector(q);
const $$=q=>document.querySelectorAll(q);
const start=new Date('2025-07-21T00:00:00');
const todayIdx=()=>{
  const now = new Date();
  const localMidnight = new Date(now.getFullYear(), now.getMonth(), now.getDate());
  const startMidnight = new Date(start.getFullYear(), start.getMonth(), start.getDate());
  return Math.floor((localMidnight.getTime()-startMidnight.getTime())/864e5);
};
const clr=['lock0','lock1','lock2'], emj=['üü©','üü®','üüß'];

/* ---------- cookie management ---------- */
let cookiesAccepted = false;

function setCookie(name, value, days = 365) {
  if (!cookiesAccepted) return;
  const expires = new Date();
  expires.setTime(expires.getTime() + (days * 24 * 60 * 60 * 1000));
  document.cookie = `${name}=${JSON.stringify(value)};expires=${expires.toUTCString()};path=/`;
}

function getCookie(name) {
  if (!cookiesAccepted) return null;
  const nameEQ = name + "=";
  const ca = document.cookie.split(';');
  for (let i = 0; i < ca.length; i++) {
    let c = ca[i];
    while (c.charAt(0) === ' ') c = c.substring(1, c.length);
    if (c.indexOf(nameEQ) === 0) {
      try {
        return JSON.parse(c.substring(nameEQ.length, c.length));
      } catch (e) {
        return null;
      }
    }
  }
  return null;
}

function checkGDPR() {
  // Check for consent cookie directly without using getCookie (which requires cookiesAccepted)
  const nameEQ = 'connecdoku_consent=';
  const ca = document.cookie.split(';');
  for (let i = 0; i < ca.length; i++) {
    let c = ca[i];
    while (c.charAt(0) === ' ') c = c.substring(1, c.length);
    if (c.indexOf(nameEQ) === 0) {
      try {
        const consent = JSON.parse(c.substring(nameEQ.length, c.length));
        cookiesAccepted = consent;
        return;
      } catch (e) {
        // Invalid cookie, continue
      }
    }
  }
  // No consent cookie found, show popup
  $('#gdprPop').classList.add('show');
}

/* ---------- statistics tracking ---------- */
let stats = {
  games: {}, // date -> strikes
  currentStreak: 0,
  longestStreak: 0,
  currentAttemptStreak: 0,
  longestAttemptStreak: 0,
  totalGames: 0,
  totalWins: 0
};

function loadStats() {
  const savedStats = getCookie('connecdoku_stats');
  if (savedStats) {
    stats = { ...stats, ...savedStats };
  }
  
  // Fix any inconsistencies in the stats
  fixStatsInconsistencies();
}

function fixStatsInconsistencies() {
  // Recalculate totalGames from actual games data
  const actualTotalGames = Object.keys(stats.games).length;
  if (stats.totalGames !== actualTotalGames) {
    console.log(`Fixing stats inconsistency: totalGames was ${stats.totalGames}, should be ${actualTotalGames}`);
    stats.totalGames = actualTotalGames;
    saveStats();
  }
}

function saveStats() {
  setCookie('connecdoku_stats', stats);
}

function updateStats(date, strikes, won) {
  // Only update if this date hasn't been recorded yet
  if (!(date in stats.games)) {
    stats.games[date] = strikes;
    stats.totalGames++;
    
    if (won) {
      stats.totalWins++;
      stats.currentStreak++;
      stats.currentAttemptStreak++;
      if (stats.currentStreak > stats.longestStreak) {
        stats.longestStreak = stats.currentStreak;
      }
      if (stats.currentAttemptStreak > stats.longestAttemptStreak) {
        stats.longestAttemptStreak = stats.currentAttemptStreak;
      }
    } else {
      stats.currentStreak = 0;
      stats.currentAttemptStreak++;
      if (stats.currentAttemptStreak > stats.longestAttemptStreak) {
        stats.longestAttemptStreak = stats.currentAttemptStreak;
      }
    }
    
    saveStats();
  }
}

function getStrikeDistribution() {
  const distribution = [0, 0, 0, 0]; // 0, 1, 2, 3 strikes
  Object.values(stats.games).forEach(strikes => {
    if (strikes >= 0 && strikes <= 3) {
      distribution[strikes]++;
    }
  });
  return distribution;
}

function getTotalGamesFromDistribution() {
  const distribution = getStrikeDistribution();
  return distribution.reduce((sum, count) => sum + count, 0);
}

/* ---------- load puzzle ---------- */
function loadGameState(currentPuzzle) {
  const savedState = getCookie('connecdoku_state');
  const currentDate = todayIdx();
  console.log('Current date index:', currentDate);
  console.log('Saved state date:', savedState ? savedState.date : 'none');
  if (savedState && savedState.date === currentDate) {
    // Additional validation: check if the saved state matches the current puzzle
    if (validateSavedState(savedState, currentPuzzle)) {
      return savedState;
    } else {
      console.log('Saved state validation failed - clearing invalid state');
      // Clear the invalid saved state
      setCookie('connecdoku_state', null, -1);
      return null;
    }
  }
  return null;
}

function validateSavedState(savedState, currentPuzzle) {
  if (!savedState || !currentPuzzle) return false;
  
  // Check if the saved state has the expected structure
  if (!savedState.grid || !Array.isArray(savedState.grid) || savedState.grid.length !== 4) {
    console.log('Saved state has invalid grid structure');
    return false;
  }
  
  // Flatten the current puzzle words and saved grid for comparison
  const currentWords = currentPuzzle.words.flat().sort();
  const savedWords = savedState.grid.flat().sort();
  
  // Check if all words match
  if (currentWords.length !== savedWords.length) {
    console.log('Word count mismatch:', currentWords.length, 'vs', savedWords.length);
    return false;
  }
  
  for (let i = 0; i < currentWords.length; i++) {
    if (currentWords[i] !== savedWords[i]) {
      console.log('Word mismatch at index', i, ':', currentWords[i], 'vs', savedWords[i]);
      return false;
    }
  }
  
  console.log('Saved state validation passed');
  return true;
}

function saveGameStateTemplate() {
  // This is a template - the actual function will be defined inside init()
  console.warn('saveGameState called before init');
}

// Initialize GDPR and stats
checkGDPR();
loadStats();

fetch('daily_puzzles/puzzles.json')
  .then(r=>r.json())
  .then(all=>init(all[todayIdx()%all.length]));

function init(puz){

  /* game vars - declare first so they can be accessed by loadGameState */
  let strikes=0, finished=false, sel=null;
  let solvedRows=new Map(), solvedCols=new Map(); // idx ‚Üí strike tier
  let G=[[],[],[],[]]; // board state
  let confirmingHeader=null; // tracks which header is in confirmation mode

  const wordToColCat = {};          // use column labels
  const wordToRowCat = {};          // use row labels

  // add next to the other game-level variables
  let colCatToIdx = null;   // { column-category ‚Üí column # }
  let rowCatToIdx = null;   // { row-category    ‚Üí row #    }

  for (let r = 0; r < 4; r++) {
    for (let c = 0; c < 4; c++) {
      const w = puz.words[r][c];
      wordToRowCat[w] = puz.rows[r];    // category of its *row*
      wordToColCat[w] = puz.cols[c];    // category of its *column*
    }
  }

  // Try to load saved game state
  const savedState = loadGameState(puz);
  console.log('Loaded saved state:', savedState);
  if (savedState) {
    strikes = savedState.strikes;
    finished = savedState.finished;
    // Reconstruct Maps with proper values (strike levels)
    solvedRows = new Map();
    solvedCols = new Map();
    if (savedState.solvedRows && savedState.solvedRows.length > 0) {
      // New format: array of [key, value] pairs
      if (Array.isArray(savedState.solvedRows[0])) {
        savedState.solvedRows.forEach(([r, level]) => solvedRows.set(r, level));
        savedState.solvedCols.forEach(([c, level]) => solvedCols.set(c, level));
      } else {
        // Old format: just keys, use current strikes as level
        savedState.solvedRows.forEach(r => solvedRows.set(r, strikes));
        savedState.solvedCols.forEach(c => solvedCols.set(c, strikes));
      }
    } else if (savedState.solvedCols && savedState.solvedCols.length > 0) {
      // Handle case where only solvedCols has data
      if (Array.isArray(savedState.solvedCols[0])) {
        savedState.solvedCols.forEach(([c, level]) => solvedCols.set(c, level));
      } else {
        savedState.solvedCols.forEach(c => solvedCols.set(c, strikes));
      }
    }
    console.log('After loading - solvedRows:', solvedRows, 'solvedCols:', solvedCols);
    G = savedState.grid;
    sel = savedState.sel ? $(`.tile[data-rc="${savedState.sel}"]`) : null;
    
    // Show hint button if there are already strikes
    if (strikes >= 1) {
      $('#hintContainer').style.display = 'block';
    }
    
    // Validate the loaded state immediately
    setTimeout(() => {
      if (!validatePuzzleState()) {
        console.error('Loaded puzzle state is invalid - clearing and restarting');
        setCookie('connecdoku_state', null, -1);
        window.location.reload();
        return;
      }
      
      if (!validatePuzzleSolvability()) {
        console.error('Loaded puzzle state is unsolvable - showing popup');
        // The popup will be shown by validatePuzzleSolvability()
      }
    }, 100); // Small delay to ensure DOM is ready
  }

  /* answer lookup */
  const hash=a=>[...a].sort().join('|');
  const ans={};
  puz.rows.forEach((l,i)=>ans[hash(puz.words[i])]=l);
  for(let c=0;c<4;c++) ans[hash(puz.words.map(r=>r[c]))]=puz.cols[c];

  const rowIdx=Object.fromEntries(puz.rows.map((l,i)=>[l,i]));
  const colIdx=Object.fromEntries(puz.cols.map((l,i)=>[l,i]));

  /* board state */
  if (!savedState) {
    // Only shuffle and initialize if we don't have saved state
  const flat=[...puz.words.flat()].map(v=>[Math.random(),v])
               .sort((a,b)=>a[0]-b[0]).map(v=>v[1]);
    let k=0;
  for(let r=0;r<4;r++)for(let c=0;c<4;c++)G[r][c]=flat[k++];
  }

  /* dynamic canonical maps (created on first solve) */
  let colPos=null; // word ‚Üí target column   (defined when first row category solved)
  let rowPos=null; // word ‚Üí target row      (defined when first column category solved)

  // Define saveGameState function inside init scope
  function saveGameState() {
    const state = {
      date: todayIdx(),
      strikes: strikes,
      finished: finished,
      solvedRows: Array.from(solvedRows.entries()),
      solvedCols: Array.from(solvedCols.entries()),
      grid: G,
      sel: sel ? sel.dataset.rc : null
    };
    console.log('Saving state:', state);
    setCookie('connecdoku_state', state);
  }

  renderBoard(); updateStrike();
  
  // Save state periodically and on key events
  setInterval(saveGameState, 30000); // Save every 30 seconds

  /* ------------------------------------------------------------
    relabelAllHeaders()  ‚Äì  hash-based, orientation-agnostic
    ‚Ä¢ Works after solveCompletely() finishes (every line is a set)
    ‚Ä¢ Reads the category from the *whole 4-word line*
    ‚Ä¢ Leaves solved headers untouched; greys unsolved ones
  ---------------------------------------------------------------- */
  function relabelAllHeaders() {
    const hash = a => [...a].sort().join('|');

    /* ‚îÄ‚îÄ rows ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
    for (let r = 0; r < 4; r++) {
      if (solvedRows.has(r)) continue;

      const hdr = document.querySelector(`.hdr[data-row="${r}"]`);
      if (!hdr) continue;

      const label = ans[hash(G[r])];
      if (label) {
        hdr.textContent = label;
        hdr.classList.add('emoji'); // Add emoji class for compound emoji support
      } else {
        hdr.textContent = '‚ùì';
        hdr.classList.add('emoji'); // Add emoji class for compound emoji support
        console.warn(
          `Row ${r}: [${G[r].join(', ')}] ‚Üí these four words don't make a category`
        );
      }
      hdr.classList.add('disabled');
      hdr.style.color = '#666';
    }

    /* ‚îÄ‚îÄ columns ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
    for (let c = 0; c < 4; c++) {
      if (solvedCols.has(c)) continue;

      const hdr = document.querySelector(`.hdr[data-col="${c}"]`);
      if (!hdr) continue;

      const colWords = [G[0][c], G[1][c], G[2][c], G[3][c]];
      const label = ans[hash(colWords)];
      if (label) {
        hdr.textContent = label;
        hdr.classList.add('emoji'); // Add emoji class for compound emoji support
      } else {
        hdr.textContent = '‚ùì';
        hdr.classList.add('emoji'); // Add emoji class for compound emoji support
        console.warn(
          `Col ${c}: [${colWords.join(', ')}] ‚Üí these four words don't make a category`
        );
      }
      hdr.classList.add('disabled');
      hdr.style.color = '#666';
    }
  }

  /* ---------- DOM ---------- */
  function renderBoard(){
    const bd=$('#board'); bd.innerHTML='';
    for(let c=0;c<4;c++) bd.appendChild(makeHdr('col',c));
    bd.appendChild(document.createElement('div'));
    for(let r=0;r<4;r++){
      for(let c=0;c<4;c++) bd.appendChild(makeTile(r,c));
      bd.appendChild(makeHdr('row',r));
    }
  }
  function makeTile(r,c){
    const d=document.createElement('div');
    d.className='tile'; d.textContent=G[r][c]; d.dataset.rc=`${r},${c}`;
    
    // Add language attribute for better hyphenation
    const text = G[r][c];
    if (text.includes('√©') || text.includes('√®') || text.includes('√†') || text.includes('√ß') || 
        text.includes('√π') || text.includes('√¢') || text.includes('√™') || text.includes('√Æ') || 
        text.includes('√¥') || text.includes('√ª') || text.includes('√´') || text.includes('√Ø') || 
        text.includes('√º') || text.includes('√ø')) {
      d.setAttribute('lang', 'fr');
    } else if (text.includes('√±') || text.includes('√°') || text.includes('√©') || 
               text.includes('√≠') || text.includes('√≥') || text.includes('√∫') || 
               text.includes('√º') || text.includes('¬ø') || text.includes('¬°')) {
      d.setAttribute('lang', 'es');
    } else {
      d.setAttribute('lang', 'en');
    }
    
    return d;
  }
  function makeHdr(kind,idx){
    const d=document.createElement('div');
    d.className='hdr clickHdr'; d.dataset[kind]=idx;
    const arrow = kind === 'row' ? '‚Üê' : '‚Üì';
    d.innerHTML=`<button class="arrow-btn">${arrow}</button>`; return d;
  }
  const tile=(r,c)=>$(`.tile[data-rc="${r},${c}"]`);
  const lockColour=(r,c,lvl)=>{
    const t=tile(r,c);
    // Only apply color if it's better (lower strike count) than existing
    const hasBetter=t.classList.contains('lock0')||(lvl>0&&t.classList.contains('lock1'))||(lvl>1&&t.classList.contains('lock2'));
    if(!hasBetter) t.classList.add(clr[lvl]);
  };
  
  /* ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    freezeTile(r,c)  ‚Äì v2
    ‚Ä¢ Marks the tile as frozen
    ‚Ä¢ Guarantees a frozen tile can never remain selected
    ‚Ä¢ Clears the global `sel` pointer when necessary
  ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
  const freezeTile = (r, c) => {
    const t = tile(r, c);
    if (!t) return;

    t.classList.add('frozen');

    if (t.classList.contains('selected')) {
      t.classList.remove('selected');
      if (sel === t) sel = null;
    }
  };

  // return a string like "StarWars|Pokemon|Fruits|Cities"
  function categorySignature(words) {
    return words     // words = 4-item array
      .map(w => ans[[...w].sort().join('|')])  // look up its category
      .join('|');
  }

  /* ---------- click handling ---------- */
  $('#board').addEventListener('click',e=>{
    if(finished) return;
    const t=e.target.closest('.tile');
    const h=e.target.closest('.clickHdr');
    
    // Handle tile clicks
    if(t && !t.classList.contains('frozen')) handleTileClick(t);
    
    // Handle header clicks
    if(h){
      const r=h.dataset.row!==undefined?+h.dataset.row:null;
      const c=h.dataset.col!==undefined?+h.dataset.col:null;
      
      // Check if header is disabled and show helpful message
      if(h.classList.contains('disabled')){
        showDisabledMessage(h, r !== null ? 'row' : 'col');
        return;
      }
      
      // If we're already in confirmation mode for a different header
      if(confirmingHeader && confirmingHeader !== h){
        // Cancel the current confirmation first
        cancelConfirmation();
        // Then start confirmation for the new header
        if(r!==null) handleHeaderClick('row',r,h);
        if(c!==null) handleHeaderClick('col',c,h);
        return;
      }
      
      if(r!==null) handleHeaderClick('row',r,h);
      if(c!==null) handleHeaderClick('col',c,h);
    } else {
      // Clicked outside headers - cancel confirmation if active
      if(confirmingHeader) cancelConfirmation();
    }
  });

  function handleTileClick(td){
    if(sel===td){ td.classList.remove('selected'); sel=null; return; }
    if(!sel){ td.classList.add('selected'); sel=td; return; }

    const [r1,c1]=sel.dataset.rc.split(',').map(Number);
    const [r2,c2]=td.dataset.rc.split(',').map(Number);
    if(solvedRows.has(r1)||solvedRows.has(r2)||solvedCols.has(c1)||solvedCols.has(c2)) return;
    
    // Clear selection immediately
    sel.classList.remove('selected'); 
    const oldSel = sel;
    sel = null;
    
    swapCells(r1,c1,r2,c2,true);
    
    // Ensure selection is cleared after animation
    setTimeout(() => {
      if (oldSel) oldSel.classList.remove('selected');
    }, 500);

    integrityCheck();
  }

  function handleHeaderClick(kind, idx, hdr) {
    if(hdr.classList.contains('solved')) return;
    
    // If not in confirmation mode, start confirmation
    if(!confirmingHeader) {
      startConfirmation(kind, idx, hdr);
    } else {
      // Already in confirmation mode for this header - execute the guess
      executeGuess(kind, idx, hdr);
    }
  }

  function startConfirmation(kind, idx, hdr) {
    // Cancel any existing confirmation
    if(confirmingHeader) cancelConfirmation();
    
    // Set up confirmation state
    confirmingHeader = hdr;
    hdr.classList.add('confirming');
    hdr.querySelector('button').textContent = 'confirm';
    hdr.querySelector('button').classList.add('confirm-btn');
    
    // Highlight the row/column being guessed
    if(kind === 'row') {
      for(let c = 0; c < 4; c++) {
        const tile = $(`.tile[data-rc="${idx},${c}"]`);
        if(tile) tile.classList.add('row-confirming');
      }
    } else {
      for(let r = 0; r < 4; r++) {
        const tile = $(`.tile[data-rc="${r},${idx}"]`);
        if(tile) tile.classList.add('col-confirming');
      }
    }
  }

  function cancelConfirmation() {
    if(!confirmingHeader) return;
    
    const hdr = confirmingHeader;
    const kind = hdr.dataset.row !== undefined ? 'row' : 'col';
    const idx = kind === 'row' ? +hdr.dataset.row : +hdr.dataset.col;
    
    // Reset header
    hdr.classList.remove('confirming');
    const arrow = kind === 'row' ? '‚Üê' : '‚Üì';
    hdr.querySelector('button').textContent = arrow;
    hdr.querySelector('button').classList.remove('confirm-btn');
    hdr.querySelector('button').classList.add('arrow-btn');
    
    // Remove highlighting
    if(kind === 'row') {
      for(let c = 0; c < 4; c++) {
        const tile = $(`.tile[data-rc="${idx},${c}"]`);
        if(tile) tile.classList.remove('row-confirming');
      }
    } else {
      for(let r = 0; r < 4; r++) {
        const tile = $(`.tile[data-rc="${r},${idx}"]`);
        if(tile) tile.classList.remove('col-confirming');
      }
    }
    
    confirmingHeader = null;
  }

  function executeGuess(kind, idx, hdr) {
    // Cancel confirmation state
    cancelConfirmation();
    
    // Execute the actual guess
    checkLine(kind, idx, hdr);
  }

  function showDisabledMessage(header, dimension) {
    // Remove any existing message
    const existingMessage = document.querySelector('.disabled-message');
    if (existingMessage) {
      existingMessage.remove();
    }
    
    // Create new message - say the opposite dimension
    const oppositeDimension = dimension === 'row' ? 'column' : 'row';
    const message = document.createElement('div');
    message.className = 'disabled-message';
    message.textContent = `You must solve a ${oppositeDimension}`;
    
    // Position the message above the header
    const rect = header.getBoundingClientRect();
    message.style.left = `${rect.left + rect.width/2}px`;
    message.style.top = `${rect.top - 10}px`;
    message.style.transform = 'translateX(-50%) translateY(-10px)';
    
    // Add to document
    document.body.appendChild(message);
    
    // Show the message
    setTimeout(() => {
      message.classList.add('show');
    }, 10);
    
    // Hide after 2 seconds
    setTimeout(() => {
      message.classList.remove('show');
      setTimeout(() => {
        if (message.parentNode) {
          message.remove();
        }
      }, 200);
    }, 2000);
  }

  /* ---------- solving logic ---------- */
  function checkLine(kind,idx,hdr,auto=false){
    if(hdr.classList.contains('solved')) return;

    if(!auto && (
      (kind==='row'&&solvedRows.size>=3&&solvedCols.size<4)||
      (kind==='col'&&solvedCols.size>=3&&solvedRows.size<4))) return;

    const words=kind==='row'?G[idx]:G.map(r=>r[idx]);
    const label=ans[hash(words)];
    if(!label) return badAttempt(hdr);
    
    console.log(`Solved ${kind} ${idx} as category: "${label}"`);

    /* ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ first *row-category* solved ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
    if (colCatToIdx === null && rowIdx[label] !== undefined) {
      // Whether we just solved a *row* or a *column* doesn't matter.
      // We only care that `label` belongs to puz.rows ‚Üí its line shows
      // us the order of the four *column* categories.
      colCatToIdx = {};

      if (kind === 'row') {
        // row solved horizontally : categories vary left ‚Üí right
        for (let c = 0; c < 4; c++) {
          const cat = wordToColCat[G[idx][c]];
          colCatToIdx[cat] = c;
        }
      } else {
        // row-category solved vertically (transpose case)
        for (let r = 0; r < 4; r++) {
          const cat = wordToColCat[G[r][idx]];
          colCatToIdx[cat] = r;    // here the *row* index is the x-coord
        }
      }
    }

    /* ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ first *column-category* solved ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
    if (rowCatToIdx === null && colIdx[label] !== undefined) {
      rowCatToIdx = {};

      if (kind === 'col') {
        // column solved vertically : row categories vary top ‚Üí bottom
        for (let r = 0; r < 4; r++) {
          const cat = wordToRowCat[G[r][idx]];
          rowCatToIdx[cat] = r;
        }
      } else {
        // column-category solved horizontally (transpose case)
        for (let c = 0; c < 4; c++) {
          const cat = wordToRowCat[G[idx][c]];
          rowCatToIdx[cat] = c;    // column index is the y-coord here
        }
      }
    }

    /* ---- update UI ---- */
    const lvl=strikes;
    const solved=kind==='row'?solvedRows:solvedCols;
    
    // Check if we should align before adding the current solve
    const shouldAlign = (kind === 'row' && solvedRows.size >= 1) || (kind === 'col' && solvedCols.size >= 1);
    
    if(shouldAlign) {
      console.log(`Aligning ${kind} ${idx}, solvedRows: ${solvedRows.size}, solvedCols: ${solvedCols.size}`);
      if(kind==='row') alignRow(idx);
      if(kind==='col') alignCol(idx);
    } else {
      console.log(`Not aligning ${kind} ${idx}, solvedRows: ${solvedRows.size}, solvedCols: ${solvedCols.size}`);
    }
    
    hdr.replaceWith(makeSolvedLabel(label,lvl));
    solved.set(idx,lvl);
    colourAndFreeze(kind,idx,lvl);

    freezeIntersections();
    if((kind==='row'&&solvedRows.size===3)||(kind==='col'&&solvedCols.size===3))
      disableSameHeaders(kind);

    if(!finished) autoEndIfObvious();
    if(solvedRows.size===4&&solvedCols.size===4) finish(true);

    saveGameState();
    integrityCheck();
    validatePuzzleState();
    
    // Check if puzzle is still solvable after alignment
    if (!validatePuzzleSolvability(true)) {
      console.log(`üîß Puzzle became unsolvable after ${kind} ${idx} alignment, trying brute-force fallback...`);
      
      // Try brute-force on the row/column that was just solved
      if (kind === 'row') {
        tryBruteForceRow(idx);
      } else if (kind === 'col') {
        tryBruteForceCol(idx);
      }
    } else {
      validatePuzzleSolvability(); // Show popup if needed
    }
  }

  function makeSolvedLabel(txt,lvl){
    const d=document.createElement('div');
    d.className=`hdr solved ${clr[lvl]} pop emoji`; d.textContent=txt; return d;
  }
  const colourAndFreeze=(k,i,l)=>{
    if(k==='row') for(let c=0;c<4;c++){ lockColour(i,c,l); freezeTile(i,c); }
    else          for(let r=0;r<4;r++){ lockColour(r,i,l); freezeTile(r,i); }
  };

  /* -----------------------------------------------
    alignRow(r)  ‚Äì put every movable word in row r
                    into the column fixed for *its*
                    column-category.
    --------------------------------------------- */
  function alignRow(r) {
    if (!colCatToIdx && !rowCatToIdx) return; // no mappings yet

    console.log(`Aligning row ${r}:`, G[r]);
    console.log('Column category mapping:', colCatToIdx);
    console.log('Row category mapping:', rowCatToIdx);
    
    // Check if this row contains column categories (transposed case)
    const rowCategories = G[r].map(w => ({
      word: w,
      rowCat: wordToRowCat[w],
      colCat: wordToColCat[w]
    }));
    const uniqueRowCats = new Set(rowCategories.map(item => item.rowCat));
    const uniqueColCats = new Set(rowCategories.map(item => item.colCat));
    
    // A row is transposed if it has multiple column categories but only one row category
    // (indicating it's a row category that contains column categories)
    const isTransposedRow = uniqueColCats.size > 1 && uniqueRowCats.size === 1;
    
    console.log(`Row appears to be ${isTransposedRow ? 'transposed (contains column categories)' : 'normal (contains row categories)'}`);
    console.log(`Row word categories:`, rowCategories);
    console.log(`Unique row categories: ${Array.from(uniqueRowCats).join(', ')}`);
    console.log(`Unique column categories: ${Array.from(uniqueColCats).join(', ')}`);
    console.log(`Row category count: ${uniqueRowCats.size}, Column category count: ${uniqueColCats.size}`);
    
    // Instead of trying every possible move, let's be more strategic
    // Only make moves that improve the alignment toward a valid solution
    
    let moved;
    let attempts = 0;
    let swaps = 0;
    const maxAttempts = 20; // Circuit breaker to prevent infinite loops
    const maxSwaps = 20; // Circuit breaker to prevent infinite swap loops
    
    do {
      moved = false;
      attempts++;
      
      if (attempts > maxAttempts) {
        console.warn(`Alignment loop detected for row ${r}, stopping after ${maxAttempts} attempts`);
        break;
      }
      
      if (swaps >= maxSwaps) {
        console.warn(`Too many swaps for row ${r}, stopping after ${maxSwaps} swaps`);
        break;
      }
      
      // For each word in this row, check if it's in the right category column
      for (let c = 0; c < 4; c++) {
        if (solvedCols.has(c)) continue; // Can't move words in solved columns
        
        const w = G[r][c];
        const wordCategory = wordToColCat[w];
        
        // Check if this word is in the right column for its category
        // (based on the canonical mapping we learned from solved lines)
        let canonicalCol = colCatToIdx ? colCatToIdx[wordCategory] : undefined;
        
        console.log(`Word "${w}" has column category "${wordCategory}", canonical col: ${canonicalCol}`);
        
        // If we don't have column mappings but we have row mappings, 
        // we might be in a transposed situation where row categories are actually column categories
        if (canonicalCol === undefined && rowCatToIdx) {
          // Check if this word belongs to a row category that we've mapped
          const rowCategory = wordToRowCat[w];
          const mappedRow = rowCatToIdx[rowCategory];
          if (mappedRow !== undefined) {
            // In transposed case, row position maps to column position
            canonicalCol = mappedRow;
            console.log(`Using transposed mapping: "${w}" (row category "${rowCategory}") -> col ${canonicalCol}`);
          }
        }
        
        // Additional check: if we're aligning a row and have both mappings,
        // we might need to use the column mapping for transposed cases
        if (canonicalCol === undefined && colCatToIdx && rowCatToIdx) {
          // This could be a case where we're aligning a row that contains column categories
          const colCategory = wordToColCat[w];
          const mappedCol = colCatToIdx[colCategory];
          if (mappedCol !== undefined) {
            canonicalCol = mappedCol;
          }
        }
        
        if (canonicalCol !== undefined && canonicalCol !== c && !solvedCols.has(canonicalCol)) {
          // This word should be in a different column within this row
          // Find the word that should be in column c
          for (let otherC = 0; otherC < 4; otherC++) {
            if (otherC === c || solvedCols.has(otherC)) continue;
            
            const otherWord = G[r][otherC];
            const otherWordCategory = wordToColCat[otherWord];
            let otherCanonicalCol = colCatToIdx ? colCatToIdx[otherWordCategory] : undefined;
            
            // Apply the same transposed logic for the other word
            if (otherCanonicalCol === undefined && rowCatToIdx) {
              const otherRowCategory = wordToRowCat[otherWord];
              const otherMappedRow = rowCatToIdx[otherRowCategory];
              if (otherMappedRow !== undefined) {
                otherCanonicalCol = otherMappedRow;
              }
            }
            
            if (otherCanonicalCol === c) {
              // Swap these two words within the row
              console.log(`Swapping "${w}" and "${otherWord}" within row ${r} (cols ${c} and ${otherC})`);
              swapCells(r, c, r, otherC, true);
              moved = true;
              break;
            }
          }
          
          if (moved) break; // Only make one move at a time to avoid loops
        }
        
                // Always try cross-references from other solved rows AND columns
        if (!moved) {
          console.log(`üîç Trying cross-reference alignment for "${w}" in row ${r}`);
          
          // Try row cross-references first (look at other solved rows)
          for (const solvedRow of solvedRows.keys()) {
            if (solvedRow === r) continue;
            
            // Find a word in the solved row that has the same row category as our word
            for (let solvedC = 0; solvedC < 4; solvedC++) {
              const solvedWord = G[solvedRow][solvedC];
              const solvedWordCategory = wordToRowCat[solvedWord];
              const ourWordCategory = wordToRowCat[w];
              
              if (solvedWordCategory === ourWordCategory) {
                // Found a word with the same row category in a solved row
                // Our word should be in the same column as this solved word
                console.log(`üîç Found row cross-reference: "${w}" (${ourWordCategory}) should align with "${solvedWord}" at column ${solvedC}`);
                
                // Find the word currently in column solvedC of our row
                const currentWordInTargetCol = G[r][solvedC];
                const currentWordCategory = wordToRowCat[currentWordInTargetCol];
                
                // If the current word in that column has a different row category, swap them
                if (currentWordCategory !== ourWordCategory) {
                  console.log(`üîç Swapping "${w}" (col ${c}) with "${currentWordInTargetCol}" (col ${solvedC}) in row ${r}`);
                  swapCells(r, c, r, solvedC, true);
                  moved = true;
                  swaps++;
                  // Don't break - continue looking for more swaps
                }
              }
            }
            // Don't break - continue looking for more swaps
          }
          
          // Try column cross-references (look at other solved columns)
          if (!moved) {
            for (const solvedCol of solvedCols.keys()) {
              if (solvedCol === c) continue;
              
              // Find a word in the solved column that has the same column category as our word
              for (let solvedR = 0; solvedR < 4; solvedR++) {
                const solvedWord = G[solvedR][solvedCol];
                const solvedWordCategory = wordToColCat[solvedWord];
                const ourWordCategory = wordToColCat[w];
                
                if (solvedWordCategory === ourWordCategory) {
                  // Found a word with the same column category in a solved column
                  // Our word should be in the same row as this solved word
                  console.log(`üîç Found column cross-reference: "${w}" (${ourWordCategory}) should align with "${solvedWord}" at row ${solvedR}`);
                  
                  // Find the word currently in row solvedR of our column
                  const currentWordInTargetRow = G[solvedR][c];
                  const currentWordCategory = wordToColCat[currentWordInTargetRow];
                  
                  // If the current word in that row has a different column category, swap them
                  if (currentWordCategory !== ourWordCategory) {
                    console.log(`üîç Swapping "${w}" (col ${c}) with "${currentWordInTargetRow}" (col ${c}) in row ${r} (moving to row ${solvedR})`);
                    swapCells(r, c, solvedR, c, true);
                    moved = true;
                    swaps++;
                    // Don't break - continue looking for more swaps
                  }
                }
              }
              // Don't break - continue looking for more swaps
            }
          }
          
          // Don't break - continue looking for more swaps
        }
      }
    } while (moved);

        console.log(`Row ${r} after alignment:`, G[r]);
    integrityCheck();
  }

  /* -----------------------------------------------
    alignCol(c)  ‚Äì put every movable word in col c
                    into the row fixed for *its*
                    row-category.
    --------------------------------------------- */
  function alignCol(c) {
    if (!rowCatToIdx && !colCatToIdx) return; // no mappings yet

    console.log(`Aligning column ${c}:`, [G[0][c], G[1][c], G[2][c], G[3][c]]);
    console.log('Row category mapping:', rowCatToIdx);
    console.log('Column category mapping:', colCatToIdx);
    
    // Debug: show what categories are in this column
    const colCategories = [G[0][c], G[1][c], G[2][c], G[3][c]].map(w => ({
      word: w,
      rowCat: wordToRowCat[w],
      colCat: wordToColCat[w]
    }));
    console.log('Column categories:', colCategories);
    
    // Check if this column contains row categories (transposed case)
    const uniqueRowCats = new Set(colCategories.map(item => item.rowCat));
    const uniqueColCats = new Set(colCategories.map(item => item.colCat));
    
    // If all words have the same row category, it's likely transposed
    const isTransposedColumn = uniqueRowCats.size === 1 && uniqueRowCats.size < uniqueColCats.size;
    
    console.log(`Column appears to be ${isTransposedColumn ? 'transposed (contains row categories)' : 'normal (contains column categories)'}`);
    console.log(`Unique row categories: ${Array.from(uniqueRowCats).join(', ')}`);
    console.log(`Unique column categories: ${Array.from(uniqueColCats).join(', ')}`);
    
    // Instead of trying every possible move, let's be more strategic
    // Only make moves that improve the alignment toward a valid solution
    
    let moved;
    let attempts = 0;
    let swaps = 0;
    const maxAttempts = 20; // Circuit breaker to prevent infinite loops
    const maxSwaps = 20; // Circuit breaker to prevent infinite swap loops
    
    do {
      moved = false;
      attempts++;
      
      if (attempts > maxAttempts) {
        console.warn(`Alignment loop detected for column ${c}, stopping after ${maxAttempts} attempts`);
        break;
      }
      
      if (swaps >= maxSwaps) {
        console.warn(`Too many swaps for column ${c}, stopping after ${maxSwaps} swaps`);
        break;
      }
      
      // For each word in this column, check if it's in the right category row
      for (let r = 0; r < 4; r++) {
        if (solvedRows.has(r)) continue; // Can't move words in solved rows
        
        const w = G[r][c];
        const wordCategory = wordToRowCat[w];
        
        // Check if this word is in the right row for its category
        // (based on the canonical mapping we learned from solved lines)
        let canonicalRow = rowCatToIdx ? rowCatToIdx[wordCategory] : undefined;
        
        console.log(`Word "${w}" has row category "${wordCategory}", canonical row: ${canonicalRow}`);
        
        // If we don't have row mappings but we have column mappings, 
        // we might be in a transposed situation where column categories are actually row categories
        if (canonicalRow === undefined && colCatToIdx) {
          // Check if this word belongs to a column category that we've mapped
          const colCategory = wordToColCat[w];
          const mappedCol = colCatToIdx[colCategory];
          if (mappedCol !== undefined) {
            // In transposed case, column position maps to row position
            canonicalRow = mappedCol;
            console.log(`Using transposed mapping: "${w}" (col category "${colCategory}") -> row ${canonicalRow}`);
          }
        }
        
        // Additional check: if we're aligning a column and have both mappings,
        // we might need to use the row mapping for transposed cases
        if (canonicalRow === undefined && rowCatToIdx && colCatToIdx) {
          // This could be a case where we're aligning a column that contains row categories
          const rowCategory = wordToRowCat[w];
          const mappedRow = rowCatToIdx[rowCategory];
          if (mappedRow !== undefined) {
            canonicalRow = mappedRow;
            console.log(`Using row mapping for column alignment: "${w}" (row category "${rowCategory}") -> row ${canonicalRow}`);
          }
        }
        
        // Special case: if we're aligning a column that was just solved and it's a row category,
        // we should prioritize using the row category mapping over the column category mapping
        if (canonicalRow === undefined && rowCatToIdx) {
          const rowCategory = wordToRowCat[w];
          const mappedRow = rowCatToIdx[rowCategory];
          if (mappedRow !== undefined) {
            canonicalRow = mappedRow;
            console.log(`Using row mapping for transposed column: "${w}" (row category "${rowCategory}") -> row ${canonicalRow}`);
          }
        }
        
        // If this is a transposed column, prioritize row category mapping
        if (isTransposedColumn && canonicalRow === undefined && rowCatToIdx) {
          const rowCategory = wordToRowCat[w];
          const mappedRow = rowCatToIdx[rowCategory];
          if (mappedRow !== undefined) {
            canonicalRow = mappedRow;
            console.log(`Using row mapping for detected transposed column: "${w}" (row category "${rowCategory}") -> row ${canonicalRow}`);
          }
        }
        
        if (canonicalRow !== undefined && canonicalRow !== r && !solvedRows.has(canonicalRow)) {
          // This word should be in a different row within this column
          // Find the word that should be in row r
          for (let otherR = 0; otherR < 4; otherR++) {
            if (otherR === r || solvedRows.has(otherR)) continue;
            
            const otherWord = G[otherR][c];
            const otherWordCategory = wordToRowCat[otherWord];
            let otherCanonicalRow = rowCatToIdx ? rowCatToIdx[otherWordCategory] : undefined;
            
            // Apply the same transposed logic for the other word
            if (otherCanonicalRow === undefined && colCatToIdx) {
              const otherColCategory = wordToColCat[otherWord];
              const otherMappedCol = colCatToIdx[otherColCategory];
              if (otherMappedCol !== undefined) {
                otherCanonicalRow = otherMappedCol;
              }
            }
            
                            if (otherCanonicalRow === r) {
                  // Swap these two words within the column
                  console.log(`Swapping "${w}" and "${otherWord}" within column ${c} (rows ${r} and ${otherR})`);
                  swapCells(r, c, otherR, c, true);
                  moved = true;
                  swaps++;
                  break;
                }
          }
          
          if (moved) break; // Only make one move at a time to avoid loops
        }
        
        // Always try cross-references from other solved columns AND rows
        if (!moved) {
          console.log(`üîç Trying cross-reference alignment for "${w}" in column ${c}`);
          
          // Try column cross-references first (look at other solved columns)
          for (const solvedCol of solvedCols.keys()) {
            if (solvedCol === c) continue;
            
            // Find a word in the solved column that has the same column category as our word
            for (let solvedR = 0; solvedR < 4; solvedR++) {
              const solvedWord = G[solvedR][solvedCol];
              const solvedWordCategory = wordToColCat[solvedWord];
              const ourWordCategory = wordToColCat[w];
              
              if (solvedWordCategory === ourWordCategory) {
                // Found a word with the same column category in a solved column
                // Our word should be in the same row as this solved word
                console.log(`üîç Found column cross-reference: "${w}" (${ourWordCategory}) should align with "${solvedWord}" at row ${solvedR}`);
                
                // Find the word currently in row solvedR of our column
                const currentWordInTargetRow = G[solvedR][c];
                const currentWordCategory = wordToColCat[currentWordInTargetRow];
                
                // If the current word in that row has a different column category, swap them
                if (currentWordCategory !== ourWordCategory) {
                  console.log(`üîç Swapping "${w}" (row ${r}) with "${currentWordInTargetRow}" (row ${solvedR}) in column ${c}`);
                  swapCells(r, c, solvedR, c, true);
                  moved = true;
                  swaps++;
                  // Don't break - continue looking for more swaps
                }
              }
            }
            // Don't break - continue looking for more swaps
          }
          
          // Try row cross-references (look at other solved rows)
          if (!moved) {
            for (const solvedRow of solvedRows.keys()) {
              if (solvedRow === r) continue;
              
              // Find a word in the solved row that has the same row category as our word
              for (let solvedC = 0; solvedC < 4; solvedC++) {
                const solvedWord = G[solvedRow][solvedC];
                const solvedWordCategory = wordToRowCat[solvedWord];
                const ourWordCategory = wordToRowCat[w];
                
                if (solvedWordCategory === ourWordCategory) {
                  // Found a word with the same row category in a solved row
                  // Our word should be in the same column as this solved word
                  console.log(`üîç Found row cross-reference: "${w}" (${ourWordCategory}) should align with "${solvedWord}" at column ${solvedC}`);
                  
                  // Find the word currently in column solvedC of our row
                  const currentWordInTargetCol = G[r][solvedC];
                  const currentWordCategory = wordToRowCat[currentWordInTargetCol];
                  
                  // If the current word in that column has a different row category, swap them
                  if (currentWordCategory !== ourWordCategory) {
                    console.log(`üîç Swapping "${w}" (row ${r}) with "${currentWordInTargetCol}" (row ${r}) in column ${c} (moving to column ${solvedC})`);
                    swapCells(r, c, r, solvedC, true);
                    moved = true;
                    swaps++;
                    // Don't break - continue looking for more swaps
                  }
                }
              }
              // Don't break - continue looking for more swaps
            }
          }
          
          // Don't break - continue looking for more swaps
        }
      }
    } while (moved);

        console.log(`Column ${c} after alignment:`, [G[0][c], G[1][c], G[2][c], G[3][c]]);
    integrityCheck();
  }

  /* -----------------------------------------------
    tryBruteForceRow(r)  ‚Äì  brute-force fallback for row alignment
    --------------------------------------------- */
  function tryBruteForceRow(r) {
    console.log(`üîß Row ${r} alignment failed, trying brute-force fallback...`);
    console.log(`üîß Current row ${r}: [${G[r].join(', ')}]`);
    
    // Generate all 24 permutations of [0,1,2,3]
    const permutations = [];
    function generatePerms(arr, start) {
      if (start === 4) {
        permutations.push([...arr]);
        return;
      }
      for (let i = start; i < 4; i++) {
        [arr[start], arr[i]] = [arr[i], arr[start]];
        generatePerms(arr, start + 1);
        [arr[start], arr[i]] = [arr[i], arr[start]];
      }
    }
    generatePerms([0, 1, 2, 3], 0);
    
    // Try each permutation
    console.log(`üîß Testing ${permutations.length} permutations for row ${r}...`);
    for (let permIndex = 0; permIndex < permutations.length; permIndex++) {
      const perm = permutations[permIndex];
      
      // Create a copy of the current row
      const originalRow = [...G[r]];
      
      // Apply the permutation to the row
      for (let i = 0; i < 4; i++) {
        G[r][i] = originalRow[perm[i]];
      }
      
      // Update the visual display
      for (let c = 0; c < 4; c++) {
        const tile = $(`.tile[data-rc="${r},${c}"]`);
        if (tile) tile.textContent = G[r][c];
      }
      
      // Check if this permutation makes the puzzle valid
      if (validatePuzzleSolvability(true)) {
        console.log(`‚úÖ Brute-force found valid permutation for row ${r} (permutation ${permIndex + 1}/24):`, perm);
        console.log(`‚úÖ New row ${r}: [${G[r].join(', ')}]`);
        
        // Update solved positions tracking for any words that moved
        for (let c = 0; c < 4; c++) {
          const word = G[r][c];
          const oldPos = solvedPositions.get(word);
          if (oldPos && (oldPos.r !== r || oldPos.c !== c)) {
            console.log(`üîß Updating solved position for "${word}" from [${oldPos.r},${oldPos.c}] to [${r},${c}]`);
            solvedPositions.set(word, { r, c });
          }
        }
        
        integrityCheck();
        return;
      }
      
      // Log progress every 6 permutations
      if ((permIndex + 1) % 6 === 0) {
        console.log(`üîß Tested ${permIndex + 1}/24 permutations for row ${r}...`);
      }
      
      // Revert the permutation
      for (let i = 0; i < 4; i++) {
        G[r][i] = originalRow[i];
      }
      
      // Update the visual display back
      for (let c = 0; c < 4; c++) {
        const tile = $(`.tile[data-rc="${r},${c}"]`);
        if (tile) tile.textContent = G[r][c];
      }
    }
    
    console.warn(`‚ùå Brute-force failed to find valid permutation for row ${r} after testing all 24 permutations`);
  }

  /* -----------------------------------------------
    tryBruteForceCol(c)  ‚Äì  brute-force fallback for column alignment
    --------------------------------------------- */
  function tryBruteForceCol(c) {
    console.log(`üîß Column ${c} alignment failed, trying brute-force fallback...`);
    console.log(`üîß Current column ${c}: [${G[0][c]}, ${G[1][c]}, ${G[2][c]}, ${G[3][c]}]`);
    
    // Generate all 24 permutations of [0,1,2,3]
    const permutations = [];
    function generatePerms(arr, start) {
      if (start === 4) {
        permutations.push([...arr]);
        return;
      }
      for (let i = start; i < 4; i++) {
        [arr[start], arr[i]] = [arr[i], arr[start]];
        generatePerms(arr, start + 1);
        [arr[start], arr[i]] = [arr[i], arr[start]];
      }
    }
    generatePerms([0, 1, 2, 3], 0);
    
    // Try each permutation
    console.log(`üîß Testing ${permutations.length} permutations for column ${c}...`);
    for (let permIndex = 0; permIndex < permutations.length; permIndex++) {
      const perm = permutations[permIndex];
      
      // Create a copy of the current column
      const originalCol = [G[0][c], G[1][c], G[2][c], G[3][c]];
      
      // Apply the permutation to the column
      for (let i = 0; i < 4; i++) {
        G[i][c] = originalCol[perm[i]];
      }
      
      // Update the visual display
      for (let r = 0; r < 4; r++) {
        const tile = $(`.tile[data-rc="${r},${c}"]`);
        if (tile) tile.textContent = G[r][c];
      }
      
      // Check if this permutation makes the puzzle valid
      if (validatePuzzleSolvability(true)) {
        console.log(`‚úÖ Brute-force found valid permutation for column ${c} (permutation ${permIndex + 1}/24):`, perm);
        console.log(`‚úÖ New column ${c}: [${G[0][c]}, ${G[1][c]}, ${G[2][c]}, ${G[3][c]}]`);
        
        // Update solved positions tracking for any words that moved
        for (let r = 0; r < 4; r++) {
          const word = G[r][c];
          const oldPos = solvedPositions.get(word);
          if (oldPos && (oldPos.r !== r || oldPos.c !== c)) {
            console.log(`üîß Updating solved position for "${word}" from [${oldPos.r},${oldPos.c}] to [${r},${c}]`);
            solvedPositions.set(word, { r, c });
          }
        }
        
        integrityCheck();
        return;
      }
      
      // Log progress every 6 permutations
      if ((permIndex + 1) % 6 === 0) {
        console.log(`üîß Tested ${permIndex + 1}/24 permutations for column ${c}...`);
      }
      
      // Revert the permutation
      for (let i = 0; i < 4; i++) {
        G[i][c] = originalCol[i];
      }
      
      // Update the visual display back
      for (let r = 0; r < 4; r++) {
        const tile = $(`.tile[data-rc="${r},${c}"]`);
        if (tile) tile.textContent = G[r][c];
      }
    }
    
    console.warn(`‚ùå Brute-force failed to find valid permutation for column ${c} after testing all 24 permutations`);
  }

  function freezeIntersections(){
    for(const r of solvedRows.keys())
      for(const c of solvedCols.keys()) freezeTile(r,c);
  }

  function disableSameHeaders(kind){
    const solvedMap=kind==='row'?solvedRows:solvedCols;
    for(let i=0;i<4;i++){
      if(solvedMap.has(i)) continue;
      const hdr=$(`.hdr[data-${kind}="${i}"]`);
      if(hdr){ 
        hdr.classList.add('disabled'); 
        hdr.innerHTML=''; 
        // Make the last unsolved header more visually obvious
        if(solvedMap.size === 3) {
          hdr.style.background = '#ffeb3b';
          hdr.style.color = '#333';
          hdr.style.fontWeight = 'bold';
          hdr.style.border = '2px solid #ffc107';
          // Add padlock icon to make it clear this is locked
          hdr.innerHTML = 'üîí';
          hdr.classList.add('emoji'); // Add emoji class for compound emoji support
        }
      }
    }
    checkAutoSolve();
  }

  function checkAutoSolve(){
    if(solvedRows.size+solvedCols.size!==6) return;
    const r=[0,1,2,3].find(i=>!solvedRows.has(i));
    const c=[0,1,2,3].find(i=>!solvedCols.has(i));
    
    // With 6 solved lines, the last row and column must already be correct
    // No need to rearrange - just auto-solve the remaining headers
    setTimeout(()=>{
      const rh=$(`.hdr[data-row="${r}"]`);
      const ch=$(`.hdr[data-col="${c}"]`);
      if(rh) checkLine('row',r,rh,true);
      if(ch) checkLine('col',c,ch,true);
    },100);
  }

  /* ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ strikes / misc ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
  function badAttempt(hdr) {

    /* mark header, add strike, shake */
    if (strikes < 3) {
    strikes++;
    hdr.classList.add(strikes === 1 ? 'used1' : 'used2');
    shake();
    updateStrike();
    saveGameState();

    // Show hint button after first strike
    if (strikes === 1) {
      $('#hintContainer').style.display = 'block';
    }

    /* third strike ‚áí auto-solve, reveal labels, end game */
      if (strikes >= 3) {

      // put every word in its true final position
      const animTime = solveCompletely();   // may be 0 ms if nothing moved

      // after swaps finish, show missing headers & freeze board
      setTimeout(() => {
        relabelAllHeaders();
        finish(false);
      }, 1000 + animTime);                  // 1 s pause + animation
      }
    }
    
    // Clear any active confirmation state
    if(confirmingHeader) cancelConfirmation();
  }


  function updateStrike(){ $('#strikeTxt').textContent=`Strikes ${strikes}/3`; }
  const shake=()=>{ $('#shell').classList.add('shake');
                    setTimeout(()=>$('#shell').classList.remove('shake'),1200); };

  /* -------------------------------------------------
    swapCells(r1, c1, r2, c2, animate = false, animOnly = false)
    ----------------------------------------------------------- */
  function swapCells(r1, c1, r2, c2, animate = false, animOnly = false) {
    if (r1 === r2 && c1 === c2) return;

    const t1 = tile(r1, c1);
    const t2 = tile(r2, c2);
    if (!t1 || !t2) return;

    /* ‚îÄ‚îÄ visual animation ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
    if (animate) {
      const a = t1.getBoundingClientRect();
      const b = t2.getBoundingClientRect();
      const dx = b.left - a.left;
      const dy = b.top - a.top;
      const opt = { duration: 500, easing: 'cubic-bezier(.4,0,.2,1)' };

      t1.animate([{ transform: `translate(${dx}px,${dy}px)` }, { transform: 'none' }], opt);
      t2.animate([{ transform: `translate(${-dx}px,${-dy}px)` }, { transform: 'none' }], opt);

      /* update the text **after** the slide completes so it looks natural */
      setTimeout(() => {
        t1.textContent = G[r1][c1];
        t2.textContent = G[r2][c2];
      }, opt.duration);
    }

    /* ‚îÄ‚îÄ logical swap (unless we're only animating) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
    if (!animOnly) {
      [G[r1][c1], G[r2][c2]] = [G[r2][c2], G[r1][c1]];
      [t1.textContent, t2.textContent] = [t2.textContent, t1.textContent];
      integrityCheck();
    }
  }

  function autoEndIfObvious(){
    if(solvedRows.size===3&&solvedCols.size<4){
      const r=[0,1,2,3].find(i=>!solvedRows.has(i));
      checkLine('row',r,$(`.hdr[data-row="${r}"]`));
    }else if(solvedCols.size===3&&solvedRows.size<4){
      const c=[0,1,2,3].find(i=>!solvedCols.has(i));
      checkLine('col',c,$(`.hdr[data-col="${c}"]`));
    }
  }

  function finish(won) {
    finished = true;

    // Cancel any active confirmation
    if(confirmingHeader) cancelConfirmation();

    // just freeze everything; leave the current board text untouched
    for (let r = 0; r < 4; r++)
      for (let c = 0; c < 4; c++)
        freezeTile(r, c);

    // Hide hint button when game is finished
    $('#hintContainer').style.display = 'none';

      // Update statistics using the same date as the game state
  const gameDate = new Date(start.getTime() + (todayIdx() * 24 * 60 * 60 * 1000)).toISOString().split('T')[0];
  updateStats(gameDate, strikes, won);

    setTimeout(() => {
      showShare(won);
      $('#shareBtn').style.display = 'block';
    }, 600);

    integrityCheck();
  }

  /* ------------------------------------------------------------
    getOrientation()
    ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    Inspect the *first* solved line (row or column). If its
    category lives in puz.rows => normal orientation,
    otherwise we treat the puzzle as transposed.
  ---------------------------------------------------------------- */
  function getOrientation() {
    if (solvedRows.size) {
      const r   = [...solvedRows.keys()][0];
      const cat = ans[hash(G[r])];                 // category of that row
      return puz.rows.includes(cat) ? 'normal' : 'transposed';
    }
    if (solvedCols.size) {
      const c   = [...solvedCols.keys()][0];
      const cat = ans[hash(G.map(r => r[c]))];     // category of that col
      return puz.cols.includes(cat) ? 'normal' : 'transposed';
    }
    return 'normal';                               // fallback until something is solved
  }

  /* ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ integrity guard v3 ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
  const solvedPositions = new Map();   // word ‚Üí { r, c }

  function integrityCheck() {
    /* 1-a. solved words may never move */
    for (let r = 0; r < 4; r++) {
      for (let c = 0; c < 4; c++) {
        if (!solvedRows.has(r) && !solvedCols.has(c)) continue;
        const w   = G[r][c];
        const pos = solvedPositions.get(w);
        if (!pos) solvedPositions.set(w, { r, c });
        else if (pos.r !== r || pos.c !== c) {
          throw new Error(`Solved word "${w}" moved from [${pos.r},${pos.c}] to [${r},${c}]`);
        }
      }
    }

    /* 1-b. every fully-solved line must hash to a known category */
    const hash = a => [...a].sort().join('|');
    for (const r of solvedRows.keys()) {
      if (!ans[hash(G[r])]) throw new Error(`Row ${r} claims solved but is not a valid set`);
    }
    for (const c of solvedCols.keys()) {
      const col = [G[0][c], G[1][c], G[2][c], G[3][c]];
      if (!ans[hash(col)]) throw new Error(`Column ${c} claims solved but is not a valid set`);
    }
  }

  function validatePuzzleState() {
    console.log('=== PUZZLE STATE VALIDATION ===');
    
    // Check if all words are still present
    const allWords = new Set();
    for (let r = 0; r < 4; r++) {
      for (let c = 0; c < 4; c++) {
        allWords.add(G[r][c]);
      }
    }
    
    const expectedWords = new Set(puz.words.flat());
    if (allWords.size !== expectedWords.size) {
      console.error('Word count mismatch!', allWords.size, 'vs', expectedWords.size);
      return false;
    }
    
    for (const word of expectedWords) {
      if (!allWords.has(word)) {
        console.error('Missing word:', word);
        return false;
      }
    }
    
    // Check alignment maps
    if (colCatToIdx) {
      console.log('Column category mapping:', colCatToIdx);
    }
    if (rowCatToIdx) {
      console.log('Row category mapping:', rowCatToIdx);
    }
    
    // Check solved state
    console.log('Solved rows:', Array.from(solvedRows.keys()));
    console.log('Solved cols:', Array.from(solvedCols.keys()));
    
    // Validate that solved lines are actually correct
    const hash = a => [...a].sort().join('|');
    for (const r of solvedRows.keys()) {
      const rowWords = G[r];
      const category = ans[hash(rowWords)];
      if (!category) {
        console.error(`Row ${r} claims solved but doesn't match any category:`, rowWords);
        return false;
      }
      console.log(`Row ${r} solved as:`, category);
    }
    
    for (const c of solvedCols.keys()) {
      const colWords = [G[0][c], G[1][c], G[2][c], G[3][c]];
      const category = ans[hash(colWords)];
      if (!category) {
        console.error(`Column ${c} claims solved but doesn't match any category:`, colWords);
        return false;
      }
      console.log(`Column ${c} solved as:`, category);
    }
    
    console.log('Puzzle state validation passed');
    return true;
  }

  function showUnsolvablePopup() {
    // Only show the popup if it's not already showing and the game isn't finished
    if (!finished && !document.getElementById('unsolvablePop').classList.contains('show')) {
      $('#unsolvablePop').classList.add('show');
    }
  }

  function validatePuzzleSolvability(silent = false) {
    if (!silent) console.log('=== CHECKING PUZZLE SOLVABILITY ===');
    
    const hash = a => [...a].sort().join('|');
    const isFrozen = (r, c) => solvedRows.has(r) || solvedCols.has(c);

    /* ‚îÄ‚îÄ helper: generate all 24 permutations of [0,1,2,3] ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
    function allPerms() {
      const res = [];
      function perm(a, l) {
        if (l === 4) res.push(a.slice());
        else for (let i = l; i < 4; i++) {
          [a[l], a[i]] = [a[i], a[l]];
          perm(a, l + 1);
          [a[l], a[i]] = [a[i], a[l]];
              }
        }
      perm([0, 1, 2, 3], 0);
      return res;
    }
    const PERMS = allPerms();               // cached once

    /* ‚îÄ‚îÄ build the two "base" grids: normal & transposed ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
    const BASE_NORMAL = puz.words;          // rows = row categories
    const BASE_TRANS  = Array.from({ length: 4 }, (_, r) =>
                            Array.from({ length: 4 }, (_, c) => puz.words[c][r]));

    /* ‚îÄ‚îÄ try every orientation / row-perm / col-perm combo ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
    let foundValidSolution = false;

    outer: for (const base of [BASE_NORMAL, BASE_TRANS]) {
      for (const rows of PERMS) {
        for (const cols of PERMS) {

          /* quick reject: must respect every frozen word */
          let ok = true;
          for (let r = 0; r < 4 && ok; r++) {
            for (let c = 0; c < 4 && ok; c++) {
              if (!isFrozen(r, c)) continue;
              const want = base[rows[r]][cols[c]];
              if (G[r][c] !== want) ok = false;
            }
          }
          if (!ok) continue;

          /* this candidate fits all anchors ‚Üí puzzle is solvable */
          foundValidSolution = true;
            if (!silent) console.log('Found valid solution with permutation:', { rows, cols });
            break outer;
          }
        }
      }

    if (foundValidSolution) {
      if (!silent) console.log('‚úÖ Puzzle is solvable');
      return true;
    } else {
      if (!silent) {
        console.error('‚ùå Puzzle is NOT solvable - no valid permutation found');
        showUnsolvablePopup();
      }
      return false;
    }
  }

  /* ------------------------------------------------------------
    solveCompletely()  ‚Äì  v7  (‚Äúbrute-force like a human‚Äù)
    -----------------------------------------------------------
    ‚Ä¢ A valid Connecdoku grid is just the canonical puzzle grid
      after (optional) transpose + a permutation of its rows +
      a permutation of its columns  ‚Üí  2 √ó 24 √ó 24 = 1 152.
    ‚Ä¢ For each candidate grid:
        ‚Äì all words in already-solved rows/cols must match
        ‚Äì otherwise skip
      The first match becomes the target.  We then swap every
      non-frozen tile into its target square and animate the lot.
  ------------------------------------------------------------ */
  function solveCompletely() {

    const hash = a => [...a].sort().join('|');
    const isFrozen = (r, c) => solvedRows.has(r) || solvedCols.has(c);

    /* ‚îÄ‚îÄ helper: generate all 24 permutations of [0,1,2,3] ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
    function allPerms() {
      const res = [];
      function perm(a, l) {
        if (l === 4) res.push(a.slice());
        else for (let i = l; i < 4; i++) {
          [a[l], a[i]] = [a[i], a[l]];
          perm(a, l + 1);
          [a[l], a[i]] = [a[i], a[l]];
              }
        }
      perm([0, 1, 2, 3], 0);
      return res;
    }
    const PERMS = allPerms();               // cached once

    /* ‚îÄ‚îÄ build the two "base" grids: normal & transposed ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
    const BASE_NORMAL = puz.words;          // rows = row categories
    const BASE_TRANS  = Array.from({ length: 4 }, (_, r) =>
                            Array.from({ length: 4 }, (_, c) => puz.words[c][r]));

    /* ‚îÄ‚îÄ try every orientation / row-perm / col-perm combo ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
    let target = null;

    outer: for (const base of [BASE_NORMAL, BASE_TRANS]) {
      for (const rows of PERMS) {
        for (const cols of PERMS) {

          /* quick reject: must respect every frozen word */
          let ok = true;
          for (let r = 0; r < 4 && ok; r++) {
            for (let c = 0; c < 4 && ok; c++) {
              if (!isFrozen(r, c)) continue;
              const want = base[rows[r]][cols[c]];
              if (G[r][c] !== want) ok = false;
            }
          }
          if (!ok) continue;

          /* this candidate fits all anchors ‚Üí accept */
          target = Array.from({ length: 4 }, (_, r) =>
                    Array.from({ length: 4 }, (_, c) =>
                      base[rows[r]][cols[c]]));
          break outer;
        }
      }
    }

    /* fallback (should never happen) */
    if (!target) {
      console.warn('solveCompletely: no compatible layout found ‚Äì falling back');
      return 0;
    }

    /* ‚îÄ‚îÄ plan swaps from current grid ‚Üí target grid ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
    const locate = new Map();                    // word ‚Üí [r,c]
    for (let r = 0; r < 4; r++)
      for (let c = 0; c < 4; c++)
        locate.set(G[r][c], [r, c]);

    const moves = [];

    for (let r = 0; r < 4; r++) {
      for (let c = 0; c < 4; c++) {

        if (isFrozen(r, c)) continue;

        const want = target[r][c];
        if (G[r][c] === want) continue;

        const [r2, c2] = locate.get(want);
        if (isFrozen(r2, c2)) continue;          // shouldn't happen

        moves.push([r, c, r2, c2]);

        /* update virtual grid + locator */
        locate.set(G[r][c], [r2, c2]);
        locate.set(want,    [r , c ]);
        [G[r][c], G[r2][c2]] = [G[r2][c2], G[r][c]];
      }
    }

    /* ‚îÄ‚îÄ animate (logical swaps already done) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
    moves.forEach((m, i) =>
      setTimeout(() => swapCells(m[0], m[1], m[2], m[3], true, true), i * 100)
    );

    return moves.length * 100;         // total animation time
  }

  /* ---------- share popup ---------- */
  let categoryEmojis = {};
  
  // Load category emojis
  fetch('data/category_emojis.json')
    .then(r => r.json())
    .then(data => { categoryEmojis = data; })
    .catch(err => console.warn('Could not load category emojis:', err));

  function emojiFor(td){ return td.classList.contains('lock0')?emj[0]:
                               td.classList.contains('lock1')?emj[1]:
                               td.classList.contains('lock2')?emj[2]:'‚¨õ'; }
  
  function getCategoryEmoji(category) {
    return categoryEmojis[category] || '‚ùì';
  }
  
  function getPuzzleCategoryEmojis() {
    // Get the 4 row categories and 4 column categories from the puzzle
    const rowEmojis = puz.rows.map(category => getCategoryEmoji(category));
    const colEmojis = puz.cols.map(category => getCategoryEmoji(category));
    
    // Return all 8 emojis in the order they appear in the final grid
    // (column categories first, then row categories)
    return colEmojis.join('') + rowEmojis.join('');
  }
  
  function createEmojiGrid() {
    const hash = a => [...a].sort().join('|');
    const rows = [];
    const cols = [];
    
    // Get row categories (either solved or current state)
    for (let r = 0; r < 4; r++) {
      if (solvedRows.has(r)) {
        // Use the solved category
        const cat = ans[hash(G[r])];
        rows.push(getCategoryEmoji(cat));
      } else {
        // Use current state to determine category
        const cat = ans[hash(G[r])];
        rows.push(getCategoryEmoji(cat));
      }
    }
    
    // Get column categories (either solved or current state)
    for (let c = 0; c < 4; c++) {
      if (solvedCols.has(c)) {
        // Use the solved category
        const colWords = [G[0][c], G[1][c], G[2][c], G[3][c]];
        const cat = ans[hash(colWords)];
        cols.push(getCategoryEmoji(cat));
      } else {
        // Use current state to determine category
        const colWords = [G[0][c], G[1][c], G[2][c], G[3][c]];
        const cat = ans[hash(colWords)];
        cols.push(getCategoryEmoji(cat));
      }
    }
    
    // Create the grid with title using the current date (same as puzzle selection)
    const currentDate = new Date().toISOString().split('T')[0].replace(/-/g, '-');
    let grid = `Connecdoku ${currentDate}\n\n`;
    grid += cols.join('') + '\n';  // Column categories at top
    for (let r = 0; r < 4; r++) {
      let row = '';
      for (let c = 0; c < 4; c++) {
        row += emojiFor(tile(r, c));
      }
      row += rows[r];  // Row category at end of each row
      grid += row + '\n';
    }
    
    return grid;
  }
  
  function getCustomTitle(won, strikes) {
    if (won) {
      if (strikes === 0) {
        const messages = ["üéâ Amazing!", "üéä Perfect!", "üåü Flawless!", "‚ú® Incredible!", "üèÜ Masterpiece!"];
        return messages[Math.floor(Math.random() * messages.length)];
      } else if (strikes === 1) {
        const messages = ["Good job!", "Well done!", "Nice work!", "Great solve!", "Solid performance!"];
        return messages[Math.floor(Math.random() * messages.length)];
      } else if (strikes === 2) {
        const messages = ["Phew! Close one.", "That was tight!", "Just made it!", "Narrow escape!", "Cutting it close!"];
        return messages[Math.floor(Math.random() * messages.length)];
      }
    } else {
      if (strikes === 3) {
        const solvedCount = solvedRows.size + solvedCols.size;
        if (solvedCount === 0) {
          const messages = ["ü§¶‚Äç‚ôÇÔ∏è Maybe try again?", "üòÖ That was... something.", "ü§∑‚Äç‚ôÇÔ∏è At least you tried?", "üíÄ Brutal."];
          return messages[Math.floor(Math.random() * messages.length)];
        } else {
          const messages = ["You'll beat it next time!", "Good try!", "Almost had it!", "Better luck next time!", "Keep practicing!"];
          return messages[Math.floor(Math.random() * messages.length)];
  }
      }
    }
    return "Connecdoku"; // fallback
  }

  function showShare(won){
    // Use the current date (same as puzzle selection) for consistency
    const currentDate = new Date().toISOString().split('T')[0].replace(/-/g, '-');
    
    $('#popTitle').textContent = getCustomTitle(won, strikes);
    $('#shareGrid').textContent = createEmojiGrid();
    $('#shareGrid').classList.add('emoji'); // Add emoji class for compound emoji support
    
    // Add statistics
    const distribution = getStrikeDistribution();
    const totalGamesFromDistribution = getTotalGamesFromDistribution();
    const winRate = totalGamesFromDistribution > 0 ? Math.round((stats.totalWins / totalGamesFromDistribution) * 100) : 0;
    const maxStrikes = Math.max(...distribution);
    
    let statsHtml = `
      <div style="margin-top:20px;padding-top:20px;border-top:1px solid #eee;">
        <h4 style="margin:0 0 10px 0;">Statistics</h4>
        <div style="display:grid;grid-template-columns:1fr 1fr;gap:15px;font-size:14px;" class="stats-grid">
          <div>Current Win Streak: <strong>${stats.currentStreak}</strong></div>
          <div>Current Attempt Streak: <strong>${stats.currentAttemptStreak}</strong></div>
          <div>Longest Win Streak: <strong>${stats.longestStreak}</strong></div>
          <div>Longest Attempt Streak: <strong>${stats.longestAttemptStreak}</strong></div>
          <div>Win Rate: <strong>${winRate}%</strong></div>
          <div>Total Games: <strong>${totalGamesFromDistribution}</strong></div>
        </div>
        <div style="margin-top:15px;">
          <div style="font-size:12px;margin-bottom:5px;">Strikes Distribution:</div>
          <div style="display:flex;gap:2px;height:20px;align-items:end;" class="strikes-chart">
    `;
    
    for (let i = 0; i < 4; i++) {
      const height = maxStrikes > 0 ? (distribution[i] / maxStrikes) * 100 : 0;
      const color = ['#4caf50', '#ffb300', '#ff9800', '#e53935'][i];
      statsHtml += `
        <div style="flex:1;background:${color};height:${height}%;min-height:2px;border-radius:1px;" title="${i} strikes: ${distribution[i]} games"></div>
      `;
    }
    
    statsHtml += `
          </div>
          <div style="display:flex;gap:2px;font-size:10px;margin-top:2px;">
            <div style="flex:1;text-align:center;">0</div>
            <div style="flex:1;text-align:center;">1</div>
            <div style="flex:1;text-align:center;">2</div>
            <div style="flex:1;text-align:center;">3</div>
          </div>
        </div>
      </div>
    `;
    
    $('#unsolved').innerHTML = statsHtml;
    $('#sharePop').classList.add('show');
  }
  $('#copy').onclick=()=>{ navigator.clipboard.writeText($('#shareGrid').textContent);
                           $('#copy').textContent='Copied!'; };
  $('#minShare').onclick=()=>{ $('#sharePop').classList.remove('show');
                               $('#shareBtn').style.display='block'; };
  $('#shareBtn').onclick=()=>{ $('#sharePop').classList.add('show'); };
  $('#returnToPuzzle').onclick=()=>{ $('#sharePop').classList.remove('show');
                                     $('#shareBtn').style.display='block'; };

  $('#helpIcon').onclick=()=>$('#helpPop').classList.add('show');
  $('#minHelp').onclick=$('#helpOK').onclick=()=>$('#helpPop').classList.remove('show');
  
  // GDPR popup handlers
  $('#acceptCookies').onclick=()=>{
    cookiesAccepted = true;
    setCookie('connecdoku_consent', true);
    $('#gdprPop').classList.remove('show');
    // Show rules popup after cookie consent
    setTimeout(() => $('#helpPop').classList.add('show'), 300);
  };
  $('#declineCookies').onclick=()=>{
    cookiesAccepted = false;
    setCookie('connecdoku_consent', false);
    $('#gdprPop').classList.remove('show');
    // Show rules popup after cookie consent
    setTimeout(() => $('#helpPop').classList.add('show'), 300);
  };
  
  // Unsolvable puzzle popup handlers
  $('#resetPuzzle').onclick=()=>{
    // Delete the current puzzle state cookie
    setCookie('connecdoku_state', null, -1);
    // Reload the page to start fresh
    window.location.reload();
  };
  $('#closeUnsolvable').onclick=()=>{
    $('#unsolvablePop').classList.remove('show');
  };
  
  // Hint button handler
  $('#hintBtn').onclick=()=>{
    const hintBtn = $('#hintBtn');
    
    if (hintBtn.textContent === 'hint') {
      // Show hint
      const categoryEmojis = getPuzzleCategoryEmojis();
      hintBtn.textContent = categoryEmojis;
      hintBtn.classList.add('emoji'); // Add emoji class for compound emoji support
    } else {
      // Hide hint
      hintBtn.textContent = 'hint';
      hintBtn.classList.remove('emoji'); // Remove emoji class
    }
  };
  
      // Restore visual state if we loaded saved state (after all functions are defined)
    if (savedState) {
      console.log('Restoring saved state:', savedState);
      console.log('solvedRows:', solvedRows);
      console.log('solvedCols:', solvedCols);
      
      // Restore solved headers
      solvedRows.forEach((level, r) => {
        console.log(`Restoring row ${r} with level ${level}`);
        const hdr = $(`.hdr[data-row="${r}"]`);
        if (hdr) {
          const words = G[r];
          const label = ans[hash(words)];
          if (label) {
            hdr.replaceWith(makeSolvedLabel(label, level));
          }
        }
      });
      
      solvedCols.forEach((level, c) => {
        console.log(`Restoring col ${c} with level ${level}`);
        const hdr = $(`.hdr[data-col="${c}"]`);
        if (hdr) {
          const colWords = [G[0][c], G[1][c], G[2][c], G[3][c]];
          const label = ans[hash(colWords)];
          if (label) {
            hdr.replaceWith(makeSolvedLabel(label, level));
          }
        }
      });
      
      // Freeze solved tiles with proper color priority
      for (let r = 0; r < 4; r++) {
        for (let c = 0; c < 4; c++) {
          const rowLevel = solvedRows.get(r);
          const colLevel = solvedCols.get(c);
          
          // Determine the best (lowest) strike level for this tile
          let bestLevel = null;
          if (rowLevel !== undefined && colLevel !== undefined) {
            bestLevel = Math.min(rowLevel, colLevel);
          } else if (rowLevel !== undefined) {
            bestLevel = rowLevel;
          } else if (colLevel !== undefined) {
            bestLevel = colLevel;
          }
          
          if (bestLevel !== null) {
            lockColour(r, c, bestLevel);
            freezeTile(r, c);
          }
        }
      }
      
      freezeIntersections();
      
      // Apply locking mechanism if 3 rows or 3 columns are solved
      if (solvedRows.size === 3 && solvedCols.size < 4) {
        disableSameHeaders('row');
      } else if (solvedCols.size === 3 && solvedRows.size < 4) {
        disableSameHeaders('col');
      }
      
      // If puzzle is already completed (either solved or failed), show share popup
      if (finished || (solvedRows.size === 4 && solvedCols.size === 4)) {
        // If finished due to 3 strikes, we need to show the correct category labels
        if (finished && strikes >= 3) {
          relabelAllHeaders();
        }
        
        setTimeout(() => {
          // Determine if it was a win or loss
          const won = solvedRows.size === 4 && solvedCols.size === 4;
          showShare(won);
          $('#shareBtn').style.display = 'block';
        }, 500);
      } else if (strikes >= 3) {
        // Handle case where game was finished with 3 strikes but finished flag wasn't set
        finished = true;
        
        // Rearrange words into proper solved positions (like after 3rd strike)
        const animTime = solveCompletely();
        
        // After swaps finish, show missing headers & freeze board
        setTimeout(() => {
          relabelAllHeaders();
          showShare(false); // false = lost
          $('#shareBtn').style.display = 'block';
        }, 1000 + animTime); // 1 s pause + animation
      }
    }
}
</script>
</body>
</html>

