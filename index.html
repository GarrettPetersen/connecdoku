<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>Connecdoku</title>
<link rel="icon" href="favicon.ico">
<meta name="viewport" content="width=device-width,initial-scale=1">
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Fredoka+One&display=swap" rel="stylesheet">
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-1401790448375434"
     crossorigin="anonymous"></script>
<style>
/* --- styles unchanged from earlier versions --- */
:root{--tile:#f6f7f8;--tile-b:#d4d5d6;--s0:#b6e7b2;--s1:#ffe680;--s2:#ffb06a;
       --txt:#222;--btn1:#4caf50;--btn2:#ffb300;--btn3:#e53935}
body{font-family:system-ui,-apple-system,Segoe UI,Helvetica,Arial,sans-serif;
     margin:0;background:#fafafa;color:var(--txt)}
#shell{max-width:850px;margin:60px auto 40px;padding:0 12px;position:relative}
#logo{font-family:'Fredoka One',cursive;font-size:48px;margin:10px 0 28px;
      text-align:center;letter-spacing:1px;color:#222}
.grid{display:grid;grid-template-columns:repeat(5,1fr);gap:10px}
.tile,.hdr{border:2px solid var(--tile-b);border-radius:12px;box-sizing:border-box}
.tile{background:var(--tile);padding:6px 8px;display:flex;align-items:center;
      justify-content:center;min-height:90px;text-align:center;cursor:pointer;
      user-select:none;transition:background-color .3s ease}
.hdr{min-height:34px;display:flex;align-items:center;justify-content:center;cursor:pointer;transition:filter .2s ease}
.hdr:hover{filter:brightness(0.9)}
.hdr button{all:unset;cursor:pointer;color:var(--txt)}
.hdr.solved{font-weight:600;border:none;cursor:default}
.hdr.solved:hover{filter:none}
.hdr.solved.pop{animation:pop .3s ease-out}
.rowCredit{margin-top:22px;font-size:13px;text-align:center;color:#777}
#helpIcon{position:absolute;top:-38px;right:16px;font-size:24px;cursor:pointer}
.strike{margin:16px 0;text-align:center;font-size:18px}
.lock0{background:var(--s0)}.lock1{background:var(--s1)}.lock2{background:var(--s2)}
.frozen{cursor:default}.selected{outline:3px solid #2196f3}
.used1{background:var(--btn2)}.used2{background:var(--btn3)}
.disabled{opacity:.5;cursor:default}.disabled button{display:none}
@keyframes pop{0%{transform:scale(.9)}70%{transform:scale(1.05)}100%{transform:scale(1)}}
@keyframes shake{0%,100%{transform:translateX(0)}20%,60%{transform:translateX(-8px)}
                 40%,80%{transform:translateX(8px)}}
.hdr.solved.pop{animation:pop 1s cubic-bezier(.34,1.56,.64,1)}
.shake{animation:shake 1.2s cubic-bezier(.36,0,.66,-.56)}
.modalBg{position:fixed;inset:0;background:rgba(0,0,0,.55);display:none;
         align-items:center;justify-content:center;z-index:20}
.modalBg.show{display:flex}
.modalCard{background:#fff;border-radius:10px;padding:26px 30px;max-width:360px}
.modalCard h3{margin-top:0}
.modalCard button.min{position:absolute;top:8px;right:10px;border:none;background:0;font-size:22px;cursor:pointer}
.modalCard button.action{margin-top:18px;padding:8px 14px;border:none;border-radius:6px;background:#4caf50;color:#fff;cursor:pointer}
#shareBtn{position:fixed;bottom:22px;right:22px;background:#4caf50;color:#fff;
          padding:10px 14px;border-radius:50px;display:none;cursor:pointer;
          box-shadow:0 2px 6px rgba(0,0,0,.25);z-index:15}
pre{white-space:pre-wrap;margin:12px 0;font-size:20px}
</style>
</head>
<body>
<div id="shell">
  <div id="helpIcon">â“</div><h1 id="logo">Connecdoku</h1>
  <div class="strike" id="strikeTxt"></div>
  <div id="board" class="grid"></div>
  <p class="rowCredit">Connecdoku was created by <a href="https://x.com/GarrettPetersen" target="_blank">@GarrettPetersen</a></p>
</div>

<!-- share popup -->
<div id="sharePop" class="modalBg">
  <div class="modalCard">
    <button class="min" id="minShare">Ã—</button>
    <h3 id="popTitle"></h3><pre id="shareGrid"></pre>
    <div id="unsolved"></div>
    <button class="action" id="copy">Copy to clipboard</button>
  </div>
</div>

<!-- GDPR popup -->
<div id="gdprPop" class="modalBg">
  <div class="modalCard">
    <h3>Cookie Consent</h3>
    <p>This website uses cookies to save your game progress and statistics. 
       This helps you continue where you left off and track your performance over time.</p>
    <p>We only use essential cookies for game functionality. No tracking or advertising cookies are used.</p>
    <div style="display:flex;gap:10px;margin-top:20px;">
      <button class="action" id="acceptCookies">Accept</button>
      <button class="action" style="background:#666" id="declineCookies">Decline</button>
    </div>
  </div>
</div>

<!-- help popup -->
<div id="helpPop" class="modalBg">
  <div class="modalCard">
    <button class="min" id="minHelp">Ã—</button>
    <h3>How to Play</h3>
    <p>Swap words by selecting two tiles.<br>
       When you think an entire <strong>row</strong> or <strong>column</strong> matches a hidden category, hit its âœ“ button.<br>
       â€¢ Correct lines lock (colour depends on your strike count).<br>
       â€¢ Wrong checks give a strike â€” after <strong>three</strong> you lose.<br>
       Solve every row <em>and</em> column to win!
    </p>
    <button class="action" id="helpOK">Got it!</button>
  </div>
</div>

<div id="shareBtn">Share</div>

<script>
/* ---------- tiny helpers ---------- */
const $=q=>document.querySelector(q);
const $$=q=>document.querySelectorAll(q);
const start=new Date('2025-07-21T00:00:00');
const todayIdx=()=>Math.floor((new Date().getTime()-start.getTime())/864e5);
const clr=['lock0','lock1','lock2'], emj=['ğŸŸ©','ğŸŸ¨','ğŸŸ§'];

/* ---------- cookie management ---------- */
let cookiesAccepted = false;

function setCookie(name, value, days = 365) {
  if (!cookiesAccepted) return;
  const expires = new Date();
  expires.setTime(expires.getTime() + (days * 24 * 60 * 60 * 1000));
  document.cookie = `${name}=${JSON.stringify(value)};expires=${expires.toUTCString()};path=/`;
}

function getCookie(name) {
  if (!cookiesAccepted) return null;
  const nameEQ = name + "=";
  const ca = document.cookie.split(';');
  for (let i = 0; i < ca.length; i++) {
    let c = ca[i];
    while (c.charAt(0) === ' ') c = c.substring(1, c.length);
    if (c.indexOf(nameEQ) === 0) {
      try {
        return JSON.parse(c.substring(nameEQ.length, c.length));
      } catch (e) {
        return null;
      }
    }
  }
  return null;
}

function checkGDPR() {
  // Check for consent cookie directly without using getCookie (which requires cookiesAccepted)
  const nameEQ = 'connecdoku_consent=';
  const ca = document.cookie.split(';');
  for (let i = 0; i < ca.length; i++) {
    let c = ca[i];
    while (c.charAt(0) === ' ') c = c.substring(1, c.length);
    if (c.indexOf(nameEQ) === 0) {
      try {
        const consent = JSON.parse(c.substring(nameEQ.length, c.length));
        cookiesAccepted = consent;
        return;
      } catch (e) {
        // Invalid cookie, continue
      }
    }
  }
  // No consent cookie found, show popup
  $('#gdprPop').classList.add('show');
}

/* ---------- statistics tracking ---------- */
let stats = {
  games: {}, // date -> strikes
  currentStreak: 0,
  longestStreak: 0,
  currentAttemptStreak: 0,
  longestAttemptStreak: 0,
  totalGames: 0,
  totalWins: 0
};

function loadStats() {
  const savedStats = getCookie('connecdoku_stats');
  if (savedStats) {
    stats = { ...stats, ...savedStats };
  }
}

function saveStats() {
  setCookie('connecdoku_stats', stats);
}

function updateStats(date, strikes, won) {
  stats.games[date] = strikes;
  stats.totalGames++;
  
  if (won) {
    stats.totalWins++;
    stats.currentStreak++;
    stats.currentAttemptStreak = 0;
    if (stats.currentStreak > stats.longestStreak) {
      stats.longestStreak = stats.currentStreak;
    }
  } else {
    stats.currentStreak = 0;
    stats.currentAttemptStreak++;
    if (stats.currentAttemptStreak > stats.longestAttemptStreak) {
      stats.longestAttemptStreak = stats.currentAttemptStreak;
    }
  }
  
  saveStats();
}

function getStrikeDistribution() {
  const distribution = [0, 0, 0, 0]; // 0, 1, 2, 3 strikes
  Object.values(stats.games).forEach(strikes => {
    if (strikes >= 0 && strikes <= 3) {
      distribution[strikes]++;
    }
  });
  return distribution;
}

/* ---------- load puzzle ---------- */
function loadGameState() {
  const savedState = getCookie('connecdoku_state');
  if (savedState && savedState.date === todayIdx()) {
    return savedState;
  }
  return null;
}

function saveGameStateTemplate() {
  // This is a template - the actual function will be defined inside init()
  console.warn('saveGameState called before init');
}

// Initialize GDPR and stats
checkGDPR();
loadStats();

fetch('daily_puzzles/puzzles.json')
  .then(r=>r.json())
  .then(all=>init(all[todayIdx()%all.length]));

function init(puz){

  /* game vars - declare first so they can be accessed by loadGameState */
  let strikes=0, finished=false, sel=null;
  let solvedRows=new Map(), solvedCols=new Map(); // idx â†’ strike tier
  let G=[[],[],[],[]]; // board state

  const wordToColCat = {};          // use column labels
  const wordToRowCat = {};          // use row labels

  for (let r = 0; r < 4; r++) {
    for (let c = 0; c < 4; c++) {
      const w = puz.words[r][c];
      wordToRowCat[w] = puz.rows[r];    // category of its *row*
      wordToColCat[w] = puz.cols[c];    // category of its *column*
    }
  }

  // Try to load saved game state
  const savedState = loadGameState();
  console.log('Loaded saved state:', savedState);
  if (savedState) {
    strikes = savedState.strikes;
    finished = savedState.finished;
    // Reconstruct Maps with proper values (strike levels)
    solvedRows = new Map();
    solvedCols = new Map();
    if (savedState.solvedRows && savedState.solvedRows.length > 0) {
      // New format: array of [key, value] pairs
      if (Array.isArray(savedState.solvedRows[0])) {
        savedState.solvedRows.forEach(([r, level]) => solvedRows.set(r, level));
        savedState.solvedCols.forEach(([c, level]) => solvedCols.set(c, level));
      } else {
        // Old format: just keys, use current strikes as level
        savedState.solvedRows.forEach(r => solvedRows.set(r, strikes));
        savedState.solvedCols.forEach(c => solvedCols.set(c, strikes));
      }
    } else if (savedState.solvedCols && savedState.solvedCols.length > 0) {
      // Handle case where only solvedCols has data
      if (Array.isArray(savedState.solvedCols[0])) {
        savedState.solvedCols.forEach(([c, level]) => solvedCols.set(c, level));
      } else {
        savedState.solvedCols.forEach(c => solvedCols.set(c, strikes));
      }
    }
    console.log('After loading - solvedRows:', solvedRows, 'solvedCols:', solvedCols);
    G = savedState.grid;
    sel = savedState.sel ? $(`.tile[data-rc="${savedState.sel}"]`) : null;
  }

  /* answer lookup */
  const hash=a=>[...a].sort().join('|');
  const ans={};
  puz.rows.forEach((l,i)=>ans[hash(puz.words[i])]=l);
  for(let c=0;c<4;c++) ans[hash(puz.words.map(r=>r[c]))]=puz.cols[c];

  const rowIdx=Object.fromEntries(puz.rows.map((l,i)=>[l,i]));
  const colIdx=Object.fromEntries(puz.cols.map((l,i)=>[l,i]));

  /* board state */
  if (!savedState) {
    // Only shuffle and initialize if we don't have saved state
  const flat=[...puz.words.flat()].map(v=>[Math.random(),v])
               .sort((a,b)=>a[0]-b[0]).map(v=>v[1]);
    let k=0;
  for(let r=0;r<4;r++)for(let c=0;c<4;c++)G[r][c]=flat[k++];
  }

  /* dynamic canonical maps (created on first solve) */
  let colPos=null; // word â†’ target column   (defined when first row category solved)
  let rowPos=null; // word â†’ target row      (defined when first column category solved)

  // Define saveGameState function inside init scope
  function saveGameState() {
    const state = {
      date: todayIdx(),
      strikes: strikes,
      finished: finished,
      solvedRows: Array.from(solvedRows.entries()),
      solvedCols: Array.from(solvedCols.entries()),
      grid: G,
      sel: sel ? sel.dataset.rc : null
    };
    console.log('Saving state:', state);
    setCookie('connecdoku_state', state);
  }

  renderBoard(); updateStrike();
  
  // Save state periodically and on key events
  setInterval(saveGameState, 30000); // Save every 30 seconds

  /* ------------------------------------------------------------
    relabelAllHeaders()  â€“  hash-based, orientation-agnostic
    â€¢ Works after solveCompletely() finishes (every line is a set)
    â€¢ Reads the category from the *whole 4-word line*
    â€¢ Leaves solved headers untouched; greys unsolved ones
  ---------------------------------------------------------------- */
  function relabelAllHeaders() {
    const hash = a => [...a].sort().join('|');

    /* â”€â”€ rows â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
    for (let r = 0; r < 4; r++) {
      if (solvedRows.has(r)) continue;

      const hdr = document.querySelector(`.hdr[data-row="${r}"]`);
      if (!hdr) continue;

      const label = ans[hash(G[r])];
      if (label) {
        hdr.textContent = label;
      } else {
        hdr.textContent = 'â“';
        console.warn(
          `Row ${r}: [${G[r].join(', ')}] â†’ these four words don't make a category`
        );
      }
      hdr.classList.add('disabled');
      hdr.style.color = '#666';
    }

    /* â”€â”€ columns â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
    for (let c = 0; c < 4; c++) {
      if (solvedCols.has(c)) continue;

      const hdr = document.querySelector(`.hdr[data-col="${c}"]`);
      if (!hdr) continue;

      const colWords = [G[0][c], G[1][c], G[2][c], G[3][c]];
      const label = ans[hash(colWords)];
      if (label) {
        hdr.textContent = label;
      } else {
        hdr.textContent = 'â“';
        console.warn(
          `Col ${c}: [${colWords.join(', ')}] â†’ these four words don't make a category`
        );
      }
      hdr.classList.add('disabled');
      hdr.style.color = '#666';
    }
  }

  /* ---------- DOM ---------- */
  function renderBoard(){
    const bd=$('#board'); bd.innerHTML='';
    for(let c=0;c<4;c++) bd.appendChild(makeHdr('col',c));
    bd.appendChild(document.createElement('div'));
    for(let r=0;r<4;r++){
      for(let c=0;c<4;c++) bd.appendChild(makeTile(r,c));
      bd.appendChild(makeHdr('row',r));
    }
  }
  function makeTile(r,c){
    const d=document.createElement('div');
    d.className='tile'; d.textContent=G[r][c]; d.dataset.rc=`${r},${c}`;
    return d;
  }
  function makeHdr(kind,idx){
    const d=document.createElement('div');
    d.className='hdr clickHdr'; d.dataset[kind]=idx;
    d.innerHTML='<button>âœ“</button>'; return d;
  }
  const tile=(r,c)=>$(`.tile[data-rc="${r},${c}"]`);
  const lockColour=(r,c,lvl)=>{
    const t=tile(r,c);
    // Only apply color if it's better (lower strike count) than existing
    const hasBetter=t.classList.contains('lock0')||(lvl>0&&t.classList.contains('lock1'))||(lvl>1&&t.classList.contains('lock2'));
    if(!hasBetter) t.classList.add(clr[lvl]);
  };
  
  /* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    freezeTile(r,c)  â€“ v2
    â€¢ Marks the tile as frozen
    â€¢ Guarantees a frozen tile can never remain selected
    â€¢ Clears the global `sel` pointer when necessary
  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
  const freezeTile = (r, c) => {
    const t = tile(r, c);
    if (!t) return;

    t.classList.add('frozen');

    if (t.classList.contains('selected')) {
      t.classList.remove('selected');
      if (sel === t) sel = null;
    }
  };

  // return a string like "StarWars|Pokemon|Fruits|Cities"
  function categorySignature(words) {
    return words     // words = 4-item array
      .map(w => ans[[...w].sort().join('|')])  // look up its category
      .join('|');
  }

  /* ---------- click handling ---------- */
  $('#board').addEventListener('click',e=>{
    if(finished) return;
    const t=e.target.closest('.tile');
    const h=e.target.closest('.clickHdr');
    if(t && !t.classList.contains('frozen')) handleTileClick(t);
    if(h){
      const r=h.dataset.row!==undefined?+h.dataset.row:null;
      const c=h.dataset.col!==undefined?+h.dataset.col:null;
      if(r!==null) checkLine('row',r,h);
      if(c!==null) checkLine('col',c,h);
    }
  });

  function handleTileClick(td){
    if(sel===td){ td.classList.remove('selected'); sel=null; return; }
    if(!sel){ td.classList.add('selected'); sel=td; return; }

    const [r1,c1]=sel.dataset.rc.split(',').map(Number);
    const [r2,c2]=td.dataset.rc.split(',').map(Number);
    if(solvedRows.has(r1)||solvedRows.has(r2)||solvedCols.has(c1)||solvedCols.has(c2)) return;
    
    // Clear selection immediately
    sel.classList.remove('selected'); 
    const oldSel = sel;
    sel = null;
    
    swapCells(r1,c1,r2,c2,true);
    
    // Ensure selection is cleared after animation
    setTimeout(() => {
      if (oldSel) oldSel.classList.remove('selected');
    }, 500);

    integrityCheck();
  }

  /* ---------- solving logic ---------- */
  function checkLine(kind,idx,hdr,auto=false){
    if(hdr.classList.contains('solved')) return;

    if(!auto && (
      (kind==='row'&&solvedRows.size>=3&&solvedCols.size<4)||
      (kind==='col'&&solvedCols.size>=3&&solvedRows.size<4))) return;

    const words=kind==='row'?G[idx]:G.map(r=>r[idx]);
    const label=ans[hash(words)];
    if(!label) return badAttempt(hdr);

    /* ---- create canonical maps on first solve ---- */
    if(colPos===null && rowIdx[label]!==undefined){        // first ROW category solved
      colPos={};                                           // build from this lineâ€™s order
      if(kind==='row') for(let c=0;c<4;c++) colPos[G[idx][c]]=c;
      else              for(let r=0;r<4;r++) colPos[G[r][idx]]=r; // row category solved vertically (transpose)
    }
    if(rowPos===null && colIdx[label]!==undefined){        // first COLUMN category solved
      rowPos={};
      if(kind==='col') for(let r=0;r<4;r++) rowPos[G[r][idx]]=r;
      else              for(let c=0;c<4;c++) rowPos[G[idx][c]]=c; // column category solved horizontally
    }

    /* ---- update UI ---- */
    const lvl=strikes;
    const solved=kind==='row'?solvedRows:solvedCols;
    
    // Check if we should align before adding the current solve
    const shouldAlign = (kind === 'row' && solvedRows.size >= 1) || (kind === 'col' && solvedCols.size >= 1);
    
    if(shouldAlign) {
      console.log(`Aligning ${kind} ${idx}, solvedRows: ${solvedRows.size}, solvedCols: ${solvedCols.size}`);
      if(kind==='row') alignRow(idx);
      if(kind==='col') alignCol(idx);
    } else {
      console.log(`Not aligning ${kind} ${idx}, solvedRows: ${solvedRows.size}, solvedCols: ${solvedCols.size}`);
    }
    
    hdr.replaceWith(makeSolvedLabel(label,lvl));
    solved.set(idx,lvl);
    colourAndFreeze(kind,idx,lvl);

    freezeIntersections();
    if((kind==='row'&&solvedRows.size===3)||(kind==='col'&&solvedCols.size===3))
      disableSameHeaders(kind);

    if(!finished) autoEndIfObvious();
    if(solvedRows.size===4&&solvedCols.size===4) finish(true);

    saveGameState();
    integrityCheck();
  }

  function makeSolvedLabel(txt,lvl){
    const d=document.createElement('div');
    d.className=`hdr solved ${clr[lvl]} pop`; d.textContent=txt; return d;
  }
  const colourAndFreeze=(k,i,l)=>{
    if(k==='row') for(let c=0;c<4;c++){ lockColour(i,c,l); freezeTile(i,c); }
    else          for(let r=0;r<4;r++){ lockColour(r,i,l); freezeTile(r,i); }
  };

  /* ---------------------------------------------------------------
    alignRow(r)                 â€“  same-orientation anchoring
    ------------------------------------------------------------- */
  function alignRow(r) {
      const refRows = [...solvedRows.keys()];
      if (refRows.length === 0) return;

  // Step 1: Infer the column category order based on solved rows
  const catOrder = [];
  const seen = new Set();

  for (const row of refRows) {
    for (let c = 0; c < 4; c++) {
      const word = G[row][c];
      const cat = wordToColCat[word];
      if (!seen.has(cat)) {
        seen.add(cat);
        catOrder.push(cat);
      }
    }
  }

  const catToIndex = Object.fromEntries(catOrder.map((cat, i) => [cat, i]));

  // Step 2: Compute desired column positions for the current row's words
  const entries = [];
      for (let c = 0; c < 4; c++) {
    const word = G[r][c];
    const cat = wordToColCat[word];
    entries.push({ word, from: c, to: catToIndex[cat] });
  }

  // Step 3: Sort entries by target column index
  entries.sort((a, b) => a.to - b.to);

  // Step 4: Move words into desired order
  const newRow = entries.map(e => e.word);

  for (let c = 0; c < 4; c++) {
    const curWord = G[r][c];
    const tgtWord = newRow[c];
    if (curWord !== tgtWord) {
      // Find tgtWord in current row
      const src = G[r].indexOf(tgtWord);
      swapCells(r, c, r, src, true);
      }
    }
  }



  /* ---------------------------------------------------------------
    alignCol(c)                 â€“  same-orientation anchoring
    ------------------------------------------------------------- */
  function alignCol(c) {
    console.log(`alignCol(${c}) called, solvedCols:`, [...solvedCols.keys()]);
    
    // reference columns = all solved columns (current column isn't solved yet)
    const refCols = [...solvedCols.keys()];
    console.log(`refCols:`, refCols);
    if (refCols.length === 0) return;

  // build catOrder from *previously* solved columns
  const catOrder = [];
  const seen = new Set();

  for (const col of refCols) {
    console.log(`Checking column ${col}:`);
    for (let r = 0; r < 4; r++) {
      const word = G[r][col];
      const cat = wordToColCat[word];  // Use column category to determine row order
      console.log(`  Row ${r}: ${word} -> ${cat}`);
      if (!seen.has(cat)) {
        seen.add(cat);
        catOrder.push(cat);
      }
    }
  }
  console.log(`catOrder:`, catOrder);

  const catToIndex = Object.fromEntries(catOrder.map((cat, i) => [cat, i]));

  // Step 2: Compute desired row positions for the current columnâ€™s words
  const entries = [];
      for (let r = 0; r < 4; r++) {
    const word = G[r][c];
    const cat = wordToColCat[word];  // Use column category to determine row order
    entries.push({ word, from: r, to: catToIndex[cat] });
  }

  // Step 3: Sort entries by target row index
  entries.sort((a, b) => a.to - b.to);
  console.log(`sorted entries:`, entries);

  // Step 4: Move words into desired order
  const newCol = entries.map(e => e.word);
  console.log(`newCol:`, newCol);

  for (let r = 0; r < 4; r++) {
    const curWord = G[r][c];
    const tgtWord = newCol[r];
    if (curWord !== tgtWord) {
      const src = G.findIndex(row => row[c] === tgtWord);
      console.log(`swapping ${curWord} at row ${r} with ${tgtWord} at row ${src}`);
      swapCells(r, c, src, c, true);
    }
  }
}



  function freezeIntersections(){
    for(const r of solvedRows.keys())
      for(const c of solvedCols.keys()) freezeTile(r,c);
  }

  function disableSameHeaders(kind){
    const solvedMap=kind==='row'?solvedRows:solvedCols;
    for(let i=0;i<4;i++){
      if(solvedMap.has(i)) continue;
      const hdr=$(`.hdr[data-${kind}="${i}"]`);
      if(hdr){ 
        hdr.classList.add('disabled'); 
        hdr.innerHTML=''; 
        // Make the last unsolved header more visually obvious
        if(solvedMap.size === 3) {
          hdr.style.background = '#ffeb3b';
          hdr.style.color = '#333';
          hdr.style.fontWeight = 'bold';
          hdr.style.border = '2px solid #ffc107';
        }
      }
    }
    checkAutoSolve();
  }

  function checkAutoSolve(){
    if(solvedRows.size+solvedCols.size!==6) return;
    const r=[0,1,2,3].find(i=>!solvedRows.has(i));
    const c=[0,1,2,3].find(i=>!solvedCols.has(i));
    
    // With 6 solved lines, the last row and column must already be correct
    // No need to rearrange - just auto-solve the remaining headers
    setTimeout(()=>{
      const rh=$(`.hdr[data-row="${r}"]`);
      const ch=$(`.hdr[data-col="${c}"]`);
      if(rh) checkLine('row',r,rh,true);
      if(ch) checkLine('col',c,ch,true);
    },100);
  }

  /* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ strikes / misc â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
  function badAttempt(hdr) {

    /* mark header, add strike, shake */
    strikes++;
    hdr.classList.add(strikes === 1 ? 'used1' : 'used2');
    shake();
    updateStrike();
    saveGameState();

    /* third strike â‡’ auto-solve, reveal labels, end game */
    if (strikes >= 3) {

      // put every word in its true final position
      const animTime = solveCompletely();   // may be 0 ms if nothing moved

      // after swaps finish, show missing headers & freeze board
      setTimeout(() => {
        relabelAllHeaders();
        finish(false);
      }, 1000 + animTime);                  // 1 s pause + animation
    }
  }


  function updateStrike(){ $('#strikeTxt').textContent=`Strikes ${strikes}/3`; }
  const shake=()=>{ $('#shell').classList.add('shake');
                    setTimeout(()=>$('#shell').classList.remove('shake'),1200); };

  /* -------------------------------------------------
    swapCells(r1, c1, r2, c2, animate = false, animOnly = false)
    ----------------------------------------------------------- */
  function swapCells(r1, c1, r2, c2, animate = false, animOnly = false) {
    if (r1 === r2 && c1 === c2) return;

    const t1 = tile(r1, c1);
    const t2 = tile(r2, c2);
    if (!t1 || !t2) return;

    /* â”€â”€ visual animation â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
    if (animate) {
      const a = t1.getBoundingClientRect();
      const b = t2.getBoundingClientRect();
      const dx = b.left - a.left;
      const dy = b.top - a.top;
      const opt = { duration: 500, easing: 'cubic-bezier(.4,0,.2,1)' };

      t1.animate([{ transform: `translate(${dx}px,${dy}px)` }, { transform: 'none' }], opt);
      t2.animate([{ transform: `translate(${-dx}px,${-dy}px)` }, { transform: 'none' }], opt);

      /* update the text **after** the slide completes so it looks natural */
      setTimeout(() => {
        t1.textContent = G[r1][c1];
        t2.textContent = G[r2][c2];
      }, opt.duration);
    }

    /* â”€â”€ logical swap (unless weâ€™re only animating) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
    if (!animOnly) {
      [G[r1][c1], G[r2][c2]] = [G[r2][c2], G[r1][c1]];
      [t1.textContent, t2.textContent] = [t2.textContent, t1.textContent];
      integrityCheck();
    }
  }

  function autoEndIfObvious(){
    if(solvedRows.size===3&&solvedCols.size<4){
      const r=[0,1,2,3].find(i=>!solvedRows.has(i));
      checkLine('row',r,$(`.hdr[data-row="${r}"]`));
    }else if(solvedCols.size===3&&solvedRows.size<4){
      const c=[0,1,2,3].find(i=>!solvedCols.has(i));
      checkLine('col',c,$(`.hdr[data-col="${c}"]`));
    }
  }

  function finish(won) {
    finished = true;

    // just freeze everything; leave the current board text untouched
    for (let r = 0; r < 4; r++)
      for (let c = 0; c < 4; c++)
        freezeTile(r, c);

    // Update statistics
    const today = new Date().toISOString().split('T')[0];
    updateStats(today, strikes, won);

    setTimeout(() => {
      showShare(won);
      $('#shareBtn').style.display = 'block';
    }, 600);

    integrityCheck();
  }

  /* ------------------------------------------------------------
    getOrientation()
    â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    Inspect the *first* solved line (row or column). If its
    category lives in puz.rows => normal orientation,
    otherwise we treat the puzzle as transposed.
  ---------------------------------------------------------------- */
  function getOrientation() {
    if (solvedRows.size) {
      const r   = [...solvedRows.keys()][0];
      const cat = ans[hash(G[r])];                 // category of that row
      return puz.rows.includes(cat) ? 'normal' : 'transposed';
    }
    if (solvedCols.size) {
      const c   = [...solvedCols.keys()][0];
      const cat = ans[hash(G.map(r => r[c]))];     // category of that col
      return puz.cols.includes(cat) ? 'normal' : 'transposed';
    }
    return 'normal';                               // fallback until something is solved
  }

  /* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ integrity guard v3 â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
  const solvedPositions = new Map();   // word â†’ { r, c }

  function integrityCheck() {
    /* 1-a. solved words may never move */
    for (let r = 0; r < 4; r++) {
      for (let c = 0; c < 4; c++) {
        if (!solvedRows.has(r) && !solvedCols.has(c)) continue;
        const w   = G[r][c];
        const pos = solvedPositions.get(w);
        if (!pos) solvedPositions.set(w, { r, c });
        else if (pos.r !== r || pos.c !== c) {
          throw new Error(`Solved word "${w}" moved from [${pos.r},${pos.c}] to [${r},${c}]`);
        }
      }
    }

    /* 1-b. every fully-solved line must hash to a known category */
    const hash = a => [...a].sort().join('|');
    for (const r of solvedRows.keys()) {
      if (!ans[hash(G[r])]) throw new Error(`Row ${r} claims solved but is not a valid set`);
    }
    for (const c of solvedCols.keys()) {
      const col = [G[0][c], G[1][c], G[2][c], G[3][c]];
      if (!ans[hash(col)]) throw new Error(`Column ${c} claims solved but is not a valid set`);
    }
  }

  /* ------------------------------------------------------------
    solveCompletely()  â€“  v7  (â€œbrute-force like a humanâ€)
    -----------------------------------------------------------
    â€¢ A valid Connecdoku grid is just the canonical puzzle grid
      after (optional) transpose + a permutation of its rows +
      a permutation of its columns  â†’  2 Ã— 24 Ã— 24 = 1 152.
    â€¢ For each candidate grid:
        â€“ all words in already-solved rows/cols must match
        â€“ otherwise skip
      The first match becomes the target.  We then swap every
      non-frozen tile into its target square and animate the lot.
  ------------------------------------------------------------ */
  function solveCompletely() {

    const hash = a => [...a].sort().join('|');
    const isFrozen = (r, c) => solvedRows.has(r) || solvedCols.has(c);

    /* â”€â”€ helper: generate all 24 permutations of [0,1,2,3] â”€â”€â”€â”€â”€â”€â”€ */
    function allPerms() {
      const res = [];
      function perm(a, l) {
        if (l === 4) res.push(a.slice());
        else for (let i = l; i < 4; i++) {
          [a[l], a[i]] = [a[i], a[l]];
          perm(a, l + 1);
          [a[l], a[i]] = [a[i], a[l]];
        }
      }
      perm([0, 1, 2, 3], 0);
      return res;
    }
    const PERMS = allPerms();               // cached once

    /* â”€â”€ build the two â€œbaseâ€ grids: normal & transposed â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
    const BASE_NORMAL = puz.words;          // rows = row categories
    const BASE_TRANS  = Array.from({ length: 4 }, (_, r) =>
                            Array.from({ length: 4 }, (_, c) => puz.words[c][r]));

    /* â”€â”€ try every orientation / row-perm / col-perm combo â”€â”€â”€â”€â”€â”€â”€ */
    let target = null;

    outer: for (const base of [BASE_NORMAL, BASE_TRANS]) {
      for (const rows of PERMS) {
        for (const cols of PERMS) {

          /* quick reject: must respect every frozen word */
          let ok = true;
          for (let r = 0; r < 4 && ok; r++) {
            for (let c = 0; c < 4 && ok; c++) {
              if (!isFrozen(r, c)) continue;
              const want = base[rows[r]][cols[c]];
              if (G[r][c] !== want) ok = false;
            }
          }
          if (!ok) continue;

          /* this candidate fits all anchors â†’ accept */
          target = Array.from({ length: 4 }, (_, r) =>
                    Array.from({ length: 4 }, (_, c) =>
                      base[rows[r]][cols[c]]));
          break outer;
        }
      }
    }

    /* fallback (should never happen) */
    if (!target) {
      console.warn('solveCompletely: no compatible layout found â€“ falling back');
      return 0;
    }

    /* â”€â”€ plan swaps from current grid â†’ target grid â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
    const locate = new Map();                    // word â†’ [r,c]
    for (let r = 0; r < 4; r++)
      for (let c = 0; c < 4; c++)
        locate.set(G[r][c], [r, c]);

    const moves = [];

    for (let r = 0; r < 4; r++) {
      for (let c = 0; c < 4; c++) {

        if (isFrozen(r, c)) continue;

        const want = target[r][c];
        if (G[r][c] === want) continue;

        const [r2, c2] = locate.get(want);
        if (isFrozen(r2, c2)) continue;          // shouldnâ€™t happen

        moves.push([r, c, r2, c2]);

        /* update virtual grid + locator */
        locate.set(G[r][c], [r2, c2]);
        locate.set(want,    [r , c ]);
        [G[r][c], G[r2][c2]] = [G[r2][c2], G[r][c]];
      }
    }

    /* â”€â”€ animate (logical swaps already done) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
    moves.forEach((m, i) =>
      setTimeout(() => swapCells(m[0], m[1], m[2], m[3], true, true), i * 100)
    );

    return moves.length * 100;         // total animation time
  }

  /* ---------- share popup ---------- */
  let categoryEmojis = {};
  
  // Load category emojis
  fetch('data/category_emojis.json')
    .then(r => r.json())
    .then(data => { categoryEmojis = data; })
    .catch(err => console.warn('Could not load category emojis:', err));

  function emojiFor(td){ return td.classList.contains('lock0')?emj[0]:
                               td.classList.contains('lock1')?emj[1]:
                               td.classList.contains('lock2')?emj[2]:'â¬›'; }
  
  function getCategoryEmoji(category) {
    return categoryEmojis[category] || 'â“';
  }
  
  function createEmojiGrid() {
    const hash = a => [...a].sort().join('|');
    const rows = [];
    const cols = [];
    
    // Get row categories (either solved or current state)
    for (let r = 0; r < 4; r++) {
      if (solvedRows.has(r)) {
        // Use the solved category
        const cat = ans[hash(G[r])];
        rows.push(getCategoryEmoji(cat));
      } else {
        // Use current state to determine category
        const cat = ans[hash(G[r])];
        rows.push(getCategoryEmoji(cat));
      }
    }
    
    // Get column categories (either solved or current state)
    for (let c = 0; c < 4; c++) {
      if (solvedCols.has(c)) {
        // Use the solved category
        const colWords = [G[0][c], G[1][c], G[2][c], G[3][c]];
        const cat = ans[hash(colWords)];
        cols.push(getCategoryEmoji(cat));
      } else {
        // Use current state to determine category
        const colWords = [G[0][c], G[1][c], G[2][c], G[3][c]];
        const cat = ans[hash(colWords)];
        cols.push(getCategoryEmoji(cat));
      }
    }
    
    // Create the grid with title
    const today = new Date();
    const dateStr = today.toISOString().split('T')[0].replace(/-/g, '-');
    let grid = `Connecdoku ${dateStr}\n\n`;
    grid += cols.join('') + '\n';  // Column categories at top
    for (let r = 0; r < 4; r++) {
      let row = '';
      for (let c = 0; c < 4; c++) {
        row += emojiFor(tile(r, c));
      }
      row += rows[r];  // Row category at end of each row
      grid += row + '\n';
    }
    
    return grid;
  }
  
  function showShare(won){
    const today = new Date();
    const dateStr = today.toISOString().split('T')[0].replace(/-/g, '-');
    
    $('#popTitle').textContent = `Connecdoku ${dateStr}`;
    $('#shareGrid').textContent = createEmojiGrid();
    
    // Add statistics
    const winRate = stats.totalGames > 0 ? Math.round((stats.totalWins / stats.totalGames) * 100) : 0;
    const distribution = getStrikeDistribution();
    const maxStrikes = Math.max(...distribution);
    
    let statsHtml = `
      <div style="margin-top:20px;padding-top:20px;border-top:1px solid #eee;">
        <h4 style="margin:0 0 10px 0;">Statistics</h4>
        <div style="display:grid;grid-template-columns:1fr 1fr;gap:15px;font-size:14px;">
          <div>Current Win Streak: <strong>${stats.currentStreak}</strong></div>
          <div>Current Attempt Streak: <strong>${stats.currentAttemptStreak}</strong></div>
          <div>Longest Win Streak: <strong>${stats.longestStreak}</strong></div>
          <div>Longest Attempt Streak: <strong>${stats.longestAttemptStreak}</strong></div>
          <div>Win Rate: <strong>${winRate}%</strong></div>
          <div>Total Games: <strong>${stats.totalGames}</strong></div>
        </div>
        <div style="margin-top:15px;">
          <div style="font-size:12px;margin-bottom:5px;">Strikes Distribution:</div>
          <div style="display:flex;gap:2px;height:20px;align-items:end;">
    `;
    
    for (let i = 0; i < 4; i++) {
      const height = maxStrikes > 0 ? (distribution[i] / maxStrikes) * 100 : 0;
      const color = ['#4caf50', '#ffb300', '#ff9800', '#e53935'][i];
      statsHtml += `
        <div style="flex:1;background:${color};height:${height}%;min-height:2px;border-radius:1px;" title="${i} strikes: ${distribution[i]} games"></div>
      `;
    }
    
    statsHtml += `
          </div>
          <div style="display:flex;gap:2px;font-size:10px;margin-top:2px;">
            <div style="flex:1;text-align:center;">0</div>
            <div style="flex:1;text-align:center;">1</div>
            <div style="flex:1;text-align:center;">2</div>
            <div style="flex:1;text-align:center;">3</div>
          </div>
        </div>
      </div>
    `;
    
    $('#unsolved').innerHTML = statsHtml;
    $('#sharePop').classList.add('show');
  }
  $('#copy').onclick=()=>{ navigator.clipboard.writeText($('#shareGrid').textContent);
                           $('#copy').textContent='Copied!'; };
  $('#minShare').onclick=()=>{ $('#sharePop').classList.remove('show');
                               $('#shareBtn').style.display='block'; };
  $('#shareBtn').onclick=()=>{ $('#sharePop').classList.add('show'); };

  $('#helpIcon').onclick=()=>$('#helpPop').classList.add('show');
  $('#minHelp').onclick=$('#helpOK').onclick=()=>$('#helpPop').classList.remove('show');
  
  // GDPR popup handlers
  $('#acceptCookies').onclick=()=>{
    cookiesAccepted = true;
    setCookie('connecdoku_consent', true);
    $('#gdprPop').classList.remove('show');
  };
  $('#declineCookies').onclick=()=>{
    cookiesAccepted = false;
    setCookie('connecdoku_consent', false);
    $('#gdprPop').classList.remove('show');
  };
  
  // Restore visual state if we loaded saved state (after all functions are defined)
  if (savedState) {
    console.log('Restoring saved state:', savedState);
    console.log('solvedRows:', solvedRows);
    console.log('solvedCols:', solvedCols);
    
    // Restore solved headers
    solvedRows.forEach((level, r) => {
      console.log(`Restoring row ${r} with level ${level}`);
      const hdr = $(`.hdr[data-row="${r}"]`);
      if (hdr) {
        const words = G[r];
        const label = ans[hash(words)];
        if (label) {
          hdr.replaceWith(makeSolvedLabel(label, level));
        }
      }
    });
    
    solvedCols.forEach((level, c) => {
      console.log(`Restoring col ${c} with level ${level}`);
      const hdr = $(`.hdr[data-col="${c}"]`);
      if (hdr) {
        const colWords = [G[0][c], G[1][c], G[2][c], G[3][c]];
        const label = ans[hash(colWords)];
        if (label) {
          hdr.replaceWith(makeSolvedLabel(label, level));
        }
      }
    });
    
    // Freeze solved tiles
    solvedRows.forEach((level, r) => {
      for (let c = 0; c < 4; c++) {
        lockColour(r, c, level);
        freezeTile(r, c);
      }
    });
    
    solvedCols.forEach((level, c) => {
      for (let r = 0; r < 4; r++) {
        lockColour(r, c, level);
        freezeTile(r, c);
      }
    });
    
    freezeIntersections();
  }
}
</script>
</body>
</html>
